<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Controle Financeiro Pessoal Completo com IA</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js' defer></script>
    <style>
        /* Define a fonte Inter para toda a página */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Cor de fundo suave */
        }

        /* Estilos para a mensagem de feedback */
        #feedback-message {
            display: none;
            padding: 12px;
            margin-top: 16px;
            border-radius: 8px;
            font-weight: 500;
            position: fixed; /* Para sobrepor outros elementos */
            bottom: 20px; /* Distância do fundo */
            left: 50%; /* Centraliza horizontalmente */
            transform: translateX(-50%); /* Ajuste fino para centralização */
            z-index: 2000; /* Garante que fique acima de outros modais/elementos */
            min-width: 300px; /* Largura mínima */
            text-align: center; /* Centraliza o texto */
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Sombra suave */
        }

        .feedback-success {
            background-color: #d1fae5;
            color: #065f46;
        }

        .feedback-error {
            background-color: #fee2e2;
            color: #991b1b;
        }

        .feedback-info {
            background-color: #e0f2fe;
            color: #075985;
        }

        /* Estilos para ocultar/mostrar elementos */
        .hidden {
            display: none !important;
        }

        /* Estilos para a seção colapsável */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 1rem;
        }

        .collapsible-header:hover {
            background-color: #f8fafc;
        }

        .collapsible-header h2 {
            margin-bottom: 0;
        }

        .arrow-icon {
            transition: transform 0.3s ease;
        }

        .arrow-icon.rotated {
            transform: rotate(90deg);
        }

        /* Estilo para transações pagas */
        .paid-transaction td { /* Aplicar a toda a linha */
            text-decoration: line-through;
            color: #9ca3af; /* gray-400, um pouco mais claro para melhor leitura */
        }
         /* Estilo para transações pendentes de meses anteriores */
        .pending-previous-month td {
            font-style: italic;
        }
        .pending-previous-month:not(.paid-transaction) td {
             font-weight: 600; /* Negrito para pendentes */
        }


        /* Estilos para o modal */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow-y: auto; 
        }

        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px; 
            margin-top: 2rem; 
            margin-bottom: 2rem; 
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }

        .modal-body label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #4a5568;
        }
        .modal-body p { 
            margin-bottom: 0.75rem;
            line-height: 1.6;
        }
        .modal-body strong { 
            font-weight: 600;
            color: #1e40af; 
        }
        .modal-body ul { 
            list-style-position: inside;
            padding-left: 0.5rem;
        }
        .modal-body ul li {
            margin-bottom: 0.5rem;
        }


        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body input[type="date"],
        .modal-body select {  
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            background-color: #fff; 
        }


        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        #imported-transactions-table-body input, 
        #imported-transactions-table-body select,
        #imported-transactions-table-body textarea {
            font-size: 0.875rem; 
            padding: 0.25rem 0.5rem; 
        }
        #imported-transactions-table-body textarea {
            min-height: 40px; 
        }
        .ai-btn-spinner { 
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spin 0.75s linear infinite;
            margin-left: 0.5em;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Estilos para a lista de metas */
        #financial-goals-list li {
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: #f9fafb; /* Fundo levemente diferente */
        }
        #financial-goals-list .goal-details p {
            margin-bottom: 0.25rem;
        }
        #financial-goals-list .goal-actions button {
            margin-right: 0.5rem;
        }
        #financial-goals-list .ai-plan-content {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background-color: #fff;
            border: 1px dashed #cbd5e1;
            border-radius: 0.375rem;
            font-size: 0.9rem;
        }
         #financial-goals-list .ai-plan-content h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1e3a8a; /* Azul mais escuro para títulos do plano */
            margin-bottom: 0.5rem;
        }
        #financial-goals-list .ai-plan-content ul {
            list-style-position: inside;
            padding-left: 0.5rem;
        }
         #financial-goals-list .ai-plan-content li {
            border: none;
            padding: 0;
            margin-bottom: 0.25rem;
            background-color: transparent;
        }

    </style>
</head>
<body class="p-4 sm:p-6 md:p-8 lg:p-10">
    <div class="max-w-5xl mx-auto bg-white rounded-xl shadow-lg p-6 sm:p-8">
        <h1 class="text-3xl sm:text-4xl font-bold text-center text-gray-800 mb-8">Controle Financeiro Pessoal Completo com IA</h1>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
            <div class="bg-blue-100 p-4 rounded-lg shadow-md">
                <h2 class="text-lg font-semibold text-blue-800">Poder de Compra Total</h2>
                <p id="total-receitas" class="text-2xl font-bold text-blue-700">R$ 0,00</p>
            </div>
            <div class="bg-red-100 p-4 rounded-lg shadow-md">
                <h2 class="text-lg font-semibold text-red-800">Despesas do Mês</h2>
                <p id="total-despesas" class="text-2xl font-bold text-red-700">R$ 0,00</p>
            </div>
            <div class="bg-green-100 p-4 rounded-lg shadow-md">
                <h2 class="text-lg font-semibold text-green-800">Saldo Consolidado</h2>
                <p id="saldo-atual" class="text-2xl font-bold text-green-700">R$ 0,00</p>
            </div>
        </div>
        <div class="bg-purple-100 p-4 rounded-lg shadow-md mb-8">
            <h2 class="text-lg font-semibold text-purple-800">Total de Faturas de Cartão (Mês Atual)</h2>
            <p id="total-card-bills" class="text-2xl font-bold text-purple-700">R$ 0,00</p>
        </div>

        <div class="mb-8 border-b pb-6 border-gray-200">
            <div id="detailed-card-bills-header" class="collapsible-header">
                <h2 class="text-2xl font-semibold text-gray-700">Faturas Detalhadas de Cartão</h2>
                <svg id="detailed-card-bills-arrow" class="arrow-icon w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </div>
            <div id="detailed-card-bills-content" class="hidden">
                <ul id="detailed-card-bills-list" class="bg-white rounded-md shadow-sm divide-y divide-gray-200">
                </ul>
                <p id="no-card-bills-message" class="text-center text-gray-500 mt-4 hidden">Nenhuma fatura de cartão para exibir.</p>
            </div>
        </div>

        <div class="mb-8 border-b pb-6 border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Gerenciar Contas</h2>
            <div class="p-4 bg-gray-50 rounded-lg shadow-sm mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Adicionar Conta</h3>
                <form id="add-account-form" class="grid grid-cols-1 sm:grid-cols-3 gap-3 items-end">
                    <div>
                        <label for="account-name" class="block text-sm font-medium text-gray-700 mb-1">Nome da Conta</label>
                        <input type="text" id="account-name" placeholder="Nome da Conta (ex: Banco X, Dinheiro)" required
                               class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                    <div>
                        <label for="account-type" class="block text-sm font-medium text-gray-700 mb-1">Tipo</label>
                        <select id="account-type"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                            <option value="overdraft">Cheque Especial</option>
                            <option value="cash">Dinheiro</option>
                        </select>
                    </div>
                    <div>
                        <label for="initial-balance" class="block text-sm font-medium text-gray-700 mb-1" id="initial-value-label">Saldo Inicial (R$)</label>
                        <input type="number" id="initial-balance" step="0.01" placeholder="Saldo Inicial (R$)" required
                               class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                    <div class="sm:col-span-3 flex justify-end">
                        <button type="submit"
                                class="px-5 py-2 bg-blue-500 text-white font-semibold rounded-md shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-400 transition duration-150 ease-in-out">
                            Adicionar
                        </button>
                    </div>
                </form>
            </div>
            <div>
                <h3 class="text-lg font-semibold text-gray-700 mb-2">Minhas Contas</h3>
                <ul id="accounts-list" class="bg-white rounded-md shadow-sm divide-y divide-gray-200">
                </ul>
            </div>
        </div>

        <div class="mb-8 border-b pb-6 border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Gerenciar Cartões de Crédito</h2>
            <div class="p-4 bg-gray-50 rounded-lg shadow-sm mb-6">
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Adicionar Cartão de Crédito</h3>
                <form id="add-credit-card-form" class="grid grid-cols-1 sm:grid-cols-3 gap-3 items-end">
                    <div>
                        <label for="card-name" class="block text-sm font-medium text-gray-700 mb-1">Nome do Cartão</label>
                        <input type="text" id="card-name" placeholder="Nome do Cartão (ex: Visa, Master)" required
                               class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 sm:text-sm">
                    </div>
                    <div>
                        <label for="card-limit" class="block text-sm font-medium text-gray-700 mb-1">Limite (R$)</label>
                        <input type="number" id="card-limit" step="0.01" placeholder="Limite (R$)" required
                               class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 sm:text-sm">
                    </div>
                    <div>
                        <label for="card-due-day" class="block text-sm font-medium text-gray-700 mb-1">Dia Venc. Fatura</label>
                        <input type="number" id="card-due-day" min="1" max="31" placeholder="Dia Venc. Fatura" required
                               class="w-full px-3 py-2 border border-gray-300 rounded-sm shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 sm:text-sm">
                    </div>
                    <div class="sm:col-span-3 flex justify-end">
                        <button type="submit"
                                class="px-5 py-2 bg-purple-500 text-white font-semibold rounded-md shadow-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-400 transition duration-150 ease-in-out">
                            Adicionar
                        </button>
                    </div>
                </form>
            </div>
            <div>
                <h3 class="text-lg font-semibold text-gray-700 mb-2">Meus Cartões</h3>
                <ul id="credit-cards-list" class="bg-white rounded-md shadow-sm divide-y divide-gray-200">
                </ul>
            </div>
        </div>

        <div class="mb-8 border-b pb-6 border-gray-200">
            <div id="financial-goals-header" class="collapsible-header">
                 <h2 class="text-2xl font-semibold text-gray-700">✨ Minhas Metas Financeiras com IA</h2>
                <svg id="financial-goals-arrow" class="arrow-icon w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </div>
            <div id="financial-goals-content" class="hidden">
                <div class="p-4 bg-gray-50 rounded-lg shadow-sm mb-6">
                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Adicionar Nova Meta</h3>
                    <form id="add-financial-goal-form" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 items-end">
                        <div>
                            <label for="goal-name" class="block text-sm font-medium text-gray-700 mb-1">Nome da Meta</label>
                            <input type="text" id="goal-name" placeholder="Ex: Viagem para a Europa" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500 sm:text-sm">
                        </div>
                        <div>
                            <label for="goal-target-amount" class="block text-sm font-medium text-gray-700 mb-1">Valor Total (R$)</label>
                            <input type="number" id="goal-target-amount" step="0.01" placeholder="15000.00" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500 sm:text-sm">
                        </div>
                        <div>
                            <label for="goal-deadline" class="block text-sm font-medium text-gray-700 mb-1">Prazo (Data Alvo)</label>
                            <input type="date" id="goal-deadline" required class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500 sm:text-sm">
                        </div>
                        <div class="sm:col-span-full flex justify-end">
                            <button type="submit" id="add-goal-ai-plan-btn" class="w-full sm:w-auto px-6 py-2 bg-green-600 text-white font-semibold rounded-md shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-150 ease-in-out flex items-center justify-center">
                                Adicionar Meta e Obter Plano da IA ✨
                                <span id="add-goal-ai-plan-spinner" class="ai-btn-spinner hidden"></span>
                            </button>
                        </div>
                    </form>
                </div>
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-2">Metas Ativas</h3>
                    <ul id="financial-goals-list">
                        </ul>
                    <p id="no-financial-goals-message" class="text-center text-gray-500 mt-4 hidden">Nenhuma meta financeira adicionada ainda.</p>
                </div>
            </div>
        </div>


        <div class="mb-8 border-b pb-6 border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Adicionar Nova Transação Manualmente</h2>
            <form id="transaction-form" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <div>
                    <label for="date" class="block text-sm font-medium text-gray-700 mb-1">Data</label>
                    <input type="date" id="date" required
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div>
                    <label for="description" class="block text-sm font-medium text-gray-700 mb-1">Descrição</label>
                    <input type="text" id="description" placeholder="Ex: Salário, Aluguel, Supermercado" required
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div>
                    <label for="value" class="block text-sm font-medium text-gray-700 mb-1">Valor (R$)</label>
                    <input type="number" id="value" step="0.01" placeholder="0.00" required
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div>
                    <label for="type" class="block text-sm font-medium text-gray-700 mb-1">Tipo</label>
                    <select id="type" required
                            class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                        <option value="receita">Receita</option>
                        <option value="despesa">Despesa</option>
                        <option value="saque">Saque (da conta)</option>
                        <option value="pix_enviado">PIX Enviado (Pagamento)</option>
                        <option value="pix_recebido">PIX Recebido</option>
                    </select>
                </div>
                <div>
                    <label for="category-select" class="block text-sm font-medium text-gray-700 mb-1">Categoria</label>
                    <div class="flex items-center space-x-2">
                        <select id="category-select" required
                                class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                        </select>
                        <button type="button" id="ai-suggest-category-btn" title="Sugerir Categoria com IA ✨" class="mt-1 p-2 bg-indigo-500 text-white rounded-md hover:bg-indigo-600 transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stars" viewBox="0 0 16 16">
                                <path d="M7.657 6.247c.11-.33.576-.33.686 0l.645 1.937a2.89 2.89 0 0 0 1.829 1.828l1.936.645c.33.11.33.576 0 .686l-1.937.645a2.89 2.89 0 0 0-1.828 1.829l-.645 1.936a.361.361 0 0 1-.686 0l-.645-1.937a2.89 2.89 0 0 0-1.828-1.828l-1.937-.645a.361.361 0 0 1 0-.686l1.937-.645a2.89 2.89 0 0 0 1.828-1.828zM3.794 1.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387A1.73 1.73 0 0 0 4.58 5.48l-.386 1.161a.217.217 0 0 1-.412 0L3.404 5.481A1.73 1.73 0 0 0 2.306 4.384l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387A1.73 1.73 0 0 0 3.404 2.31zM10.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.16 1.16 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.16 1.16 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732z"/>
                            </svg>
                            <span id="ai-suggest-category-spinner" class="ai-btn-spinner hidden"></span>
                        </button>
                    </div>
                    <input type="text" id="new-category-input" placeholder="Nova Categoria"
                           class="mt-2 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm hidden">
                </div>
                <div>
                    <label for="account-select" class="block text-sm font-medium text-gray-700 mb-1">Conta / Cartão (Opcional)</label>
                    <select id="account-select"
                            class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </select>
                </div>
                <div class="col-span-1 sm:col-span-2 lg:col-span-1">
                    <label for="installments" class="block text-sm font-medium text-gray-700 mb-1">Parcelas (total)</label>
                    <input type="number" id="installments" min="1" value="1"
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div class="col-span-1 sm:col-span-2 lg:col-span-1"> <label for="installments-paid" class="block text-sm font-medium text-gray-700 mb-1">Parcelas já pagas</label>
                    <input type="number" id="installments-paid" min="0" value="0"
                           class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div class="sm:col-span-2 lg:col-span-full flex items-end justify-end">
                    <button type="submit"
                            class="w-full sm:w-auto px-6 py-2 bg-blue-600 text-white font-semibold rounded-md shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out">
                        Adicionar Transação
                    </button>
                </div>
            </form>
        </div>

        <div class="mb-8 border-b pb-6 border-gray-200">
            <div id="import-header" class="collapsible-header">
                <h2 class="text-2xl font-semibold text-gray-700">Importar Extratos</h2>
                <svg id="import-arrow" class="arrow-icon w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </div>
            
            <div id="import-section-content" class="hidden">
                <p class="text-sm text-gray-600 mb-4">
                    Seu arquivo deve ser OFX, CSV, Excel, Word (.docx) ou Imagem (.png, .jpg) e conter informações de transação com Data, Descrição, Valor e Tipo.
                    <span class="font-bold text-red-600">Atenção: Integração direta com bancos (Open Finance) não é possível em uma aplicação web no navegador por motivos de segurança e privacidade.</span>
                    <span class="font-bold text-orange-600">Importação de Word e Imagem é experimental: a extração automática é limitada e exigirá revisão cuidadosa dos dados.</span>
                </p>

                <div class="p-4 bg-gray-50 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold text-gray-700 mb-3">Carregar Arquivo de Extrato</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 items-end">
                        <div>
                            <label for="file-input" class="block text-sm font-medium text-gray-700 mb-1">Selecione o Arquivo</label>
                            <input type="file" id="file-input" accept=".ofx, .csv, .xls, .xlsx, .doc, .docx, .png, .jpg, .jpeg, .gif, .bmp, .tiff, .webp"
                                   class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-gray-100 file:text-gray-700 hover:file:bg-gray-200 cursor-pointer">
                        </div>
                        <div class="flex justify-end col-span-full sm:col-span-1">
                            <button id="import-file-btn"
                                    class="w-full sm:w-auto px-6 py-2 bg-indigo-600 text-white font-semibold rounded-md shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-150 ease-in-out">
                                Carregar para Revisão
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            </div>
         <div id="feedback-message"></div> <div id="import-review-section" class="mb-8 border-b pb-6 border-gray-200 hidden">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Revisar Transações Importadas</h2>
            <p class="text-sm text-gray-600 mb-4">
                Vincule cada transação importada a uma de suas contas ou cartões e ajuste os dados conforme necessário.
                 <span class="font-bold text-orange-600">Para Word/Imagem, a descrição pode conter o texto extraído; ajuste os campos.</span>
            </p>
            <div class="overflow-x-auto rounded-lg shadow-md mb-4">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-yellow-50">
                        <tr>
                            <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Data</th>
                            <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Descrição</th>
                            <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Valor</th>
                            <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Tipo</th>
                            <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Categoria</th>
                            <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Parcelas (Tot/Pagas)</th> <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Vincular a</th>
                            <th scope="col" class="px-2 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Status</th>
                        </tr>
                    </thead>
                    <tbody id="imported-transactions-table-body" class="bg-white divide-y divide-gray-200">
                    </tbody>
                </table>
            </div>
            <div class="flex justify-end gap-4">
                <button id="cancel-review-btn"
                        class="px-6 py-2 bg-gray-400 text-white font-semibold rounded-md shadow-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 transition duration-150 ease-in-out">
                    Cancelar Importação
                </button>
                <button id="confirm-import-btn"
                        class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-md shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out">
                    Confirmar Importação
                </button>
            </div>
        </div>

        <div class="mb-8 border-b pb-6 border-gray-200">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Baixar Planilha</h2>
            <button id="download-xlsx-btn"
                    class="w-full sm:w-auto px-6 py-2 bg-gray-600 text-white font-semibold rounded-md shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition duration-150 ease-in-out">
                Baixar Transações (com pendências) como Excel (.xlsx)
            </button>
        </div>

        <div>
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-gray-700">Minhas Transações</h2>
                <button id="ai-analyze-expenses-btn" class="px-4 py-2 bg-teal-500 text-white font-semibold rounded-md shadow-md hover:bg-teal-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-400 transition duration-150 ease-in-out flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard2-data mr-2" viewBox="0 0 16 16">
                        <path d="M9.5 0a.5.5 0 0 1 .5.5.5.5 0 0 0 .5.5.5.5 0 0 1 .5.5V2a.5.5 0 0 1-.5.5h-5A.5.5 0 0 1 5 2V1.5a.5.5 0 0 1 .5-.5.5.5 0 0 0 .5-.5.5.5 0 0 1 .5-.5z"/>
                        <path d="M3 2.5a.5.5 0 0 1 .5-.5H4a.5.5 0 0 0 0-1h-.5A1.5 1.5 0 0 0 2 2.5v12A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-12A1.5 1.5 0 0 0 12.5 1H12a.5.5 0 0 0 0 1h.5a.5.5 0 0 1 .5.5v12a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/>
                        <path d="M10 7a1 1 0 1 1 2 0v5a1 1 0 1 1-2 0zm-6 4a1 1 0 1 1 2 0v1a1 1 0 1 1-2 0zm4-3a1 1 0 0 1 1 1v3a1 1 0 1 1-2 0V9a1 1 0 0 1 1-1"/>
                    </svg>
                    Analisar Gastos do Mês com IA
                    <span id="ai-analyze-expenses-spinner" class="ai-btn-spinner hidden"></span>
                </button>
            </div>
            <div class="flex items-center space-x-4 mb-4">
                <button id="prev-month-btn" class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300">Anterior</button>
                <span id="current-month-display" class="text-lg font-semibold text-gray-800"></span>
                <button id="next-month-btn" class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300">Próximo</button>
            </div>
            <div class="overflow-x-auto rounded-lg shadow-md">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Data</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Descrição</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Valor</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Tipo</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoria</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Conta / Cartão</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Parcela</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Ações</th>
                        </tr>
                    </thead>
                    <tbody id="transaction-list" class="bg-white divide-y divide-gray-200">
                    </tbody>
                </table>
            </div>
            <p id="no-transactions-message" class="text-center text-gray-500 mt-4 hidden">Nenhuma transação registrada ainda.</p>
        </div>

    </div>

    <div id="edit-transaction-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Editar Transação</h3>
                <button class="modal-close-btn" id="close-edit-modal">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="edit-transaction-id">
                
                <label for="edit-date">Data:</label>
                <input type="date" id="edit-date">

                <label for="edit-description">Descrição:</label>
                <input type="text" id="edit-description">

                <label for="edit-value">Valor:</label>
                <input type="number" id="edit-value" step="0.01">
                
                <label for="edit-category">Categoria:</label>
                <select id="edit-category" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm mb-4"></select>
                <input type="text" id="edit-new-category" placeholder="Nova Categoria (se 'Adicionar Nova...' selecionada)" class="hidden w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm mb-4">

                <label for="edit-installments-total">Parcelas (Total):</label>
                <input type="text" id="edit-installments-total" readonly class="bg-gray-100 cursor-not-allowed">

                <label for="edit-installments-paid">Parcelas já pagas:</label>
                <input type="number" id="edit-installments-paid" min="0" required>
            </div>
            <div class="modal-footer">
                <button id="save-edit-transaction-btn"
                        class="px-4 py-2 bg-blue-500 text-white font-semibold rounded-md shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-400 transition duration-150 ease-in-out">
                    Salvar Alterações
                </button>
                <button id="cancel-edit-transaction-btn"
                        class="px-4 py-2 bg-gray-400 text-white font-semibold rounded-md shadow-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 transition duration-150 ease-in-out">
                    Cancelar
                </button>
            </div>
        </div>
    </div>

    <div id="ai-analysis-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="ai-analysis-modal-title">Análise de Gastos com IA</h3>
                <button class="modal-close-btn" id="close-ai-analysis-modal">&times;</button>
            </div>
            <div class="modal-body" id="ai-analysis-modal-body">
                <p>Carregando análise...</p>
            </div>
            <div class="modal-footer">
                <button id="ok-ai-analysis-modal-btn"
                        class="px-4 py-2 bg-blue-500 text-white font-semibold rounded-md shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-400 transition duration-150 ease-in-out">
                    OK
                </button>
            </div>
        </div>
    </div>

     <div id="ai-goal-plan-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="ai-goal-plan-modal-title">Plano da Meta com IA</h3>
                <button class="modal-close-btn" id="close-ai-goal-plan-modal">&times;</button>
            </div>
            <div class="modal-body" id="ai-goal-plan-modal-body">
                <p>Carregando plano...</p>
            </div>
            <div class="modal-footer">
                <button id="ok-ai-goal-plan-modal-btn"
                        class="px-4 py-2 bg-green-500 text-white font-semibold rounded-md shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-400 transition duration-150 ease-in-out">
                    Entendido
                </button>
            </div>
        </div>
    </div>


    <script>
        // Arrays globais para armazenar dados
        let accounts = [];
        let creditCards = [];
        let transactions = [];
        let categories = [
            "Alimentação", "Transporte", "Moradia", "Lazer", "Saúde", "Educação",
            "Salário", "Investimentos", "Contas Fixas", "Compras", "Outros"
        ];
        let financialGoals = []; 

        // Array temporário para transações importadas pendentes de revisão
        let importedTransactionsToReview = [];
        // Mês e ano atuais para o resumo mensal e filtro de transações
        let currentMonth = new Date().getMonth(); 
        let currentYear = new Date().getFullYear();

        let expensesChart = null; 

        // Referências aos elementos do DOM
        const totalReceitasEl = document.getElementById('total-receitas');
        const totalDespesasEl = document.getElementById('total-despesas');
        const saldoAtualEl = document.getElementById('saldo-atual');
        const totalCardBillsEl = document.getElementById('total-card-bills');
        const noTransactionsMessage = document.getElementById('no-transactions-message');
        const feedbackMessageEl = document.getElementById('feedback-message');
        const addAccountForm = document.getElementById('add-account-form');
        const accountsList = document.getElementById('accounts-list');
        const addCreditCardForm = document.getElementById('add-credit-card-form');
        const creditCardsList = document.getElementById('credit-cards-list');
        const accountSelect = document.getElementById('account-select'); 
        const accountTypeSelect = document.getElementById('account-type'); 
        const initialBalanceInput = document.getElementById('initial-balance');
        const initialValueLabel = document.getElementById('initial-value-label'); 
        const cardDueDayInput = document.getElementById('card-due-day');
        const transactionForm = document.getElementById('transaction-form');
        const transactionList = document.getElementById('transaction-list');
        const installmentsInput = document.getElementById('installments');
        const installmentsPaidInput = document.getElementById('installments-paid'); 
        const transactionTypeSelect = document.getElementById('type');
        const categorySelect = document.getElementById('category-select');
        const newCategoryInput = document.getElementById('new-category-input');
        const aiSuggestCategoryBtn = document.getElementById('ai-suggest-category-btn'); 
        const aiSuggestCategorySpinner = document.getElementById('ai-suggest-category-spinner'); 
        const importHeader = document.getElementById('import-header');
        const importSectionContent = document.getElementById('import-section-content');
        const importArrow = document.getElementById('import-arrow');
        const importReviewSection = document.getElementById('import-review-section');
        const importedTransactionsTableBody = document.getElementById('imported-transactions-table-body');
        const confirmImportBtn = document.getElementById('confirm-import-btn');
        const cancelReviewBtn = document.getElementById('cancel-review-btn');
        const fileInput = document.getElementById('file-input');
        const importFileBtn = document.getElementById('import-file-btn');
        const prevMonthBtn = document.getElementById('prev-month-btn');
        const nextMonthBtn = document.getElementById('next-month-btn');
        const currentMonthDisplay = document.getElementById('current-month-display');
        const downloadXlsxBtn = document.getElementById('download-xlsx-btn');
        const detailedCardBillsHeader = document.getElementById('detailed-card-bills-header');
        const detailedCardBillsContent = document.getElementById('detailed-card-bills-content');
        const detailedCardBillsArrow = document.getElementById('detailed-card-bills-arrow');
        const detailedCardBillsList = document.getElementById('detailed-card-bills-list');
        const noCardBillsMessage = document.getElementById('no-card-bills-message');
        const editTransactionModal = document.getElementById('edit-transaction-modal');
        const closeEditModalBtn = document.getElementById('close-edit-modal');
        const saveEditTransactionBtn = document.getElementById('save-edit-transaction-btn');
        const cancelEditTransactionBtn = document.getElementById('cancel-edit-transaction-btn');
        const editTransactionIdInput = document.getElementById('edit-transaction-id');
        const editDateInput = document.getElementById('edit-date'); 
        const editDescriptionInput = document.getElementById('edit-description');
        const editValueInput = document.getElementById('edit-value');
        const editCategorySelect = document.getElementById('edit-category'); 
        const editNewCategoryInput = document.getElementById('edit-new-category'); 
        const editInstallmentsTotalInput = document.getElementById('edit-installments-total');
        const editInstallmentsPaidInput = document.getElementById('edit-installments-paid');
        const aiAnalyzeExpensesBtn = document.getElementById('ai-analyze-expenses-btn');
        const aiAnalyzeExpensesSpinner = document.getElementById('ai-analyze-expenses-spinner');
        const aiAnalysisModal = document.getElementById('ai-analysis-modal');
        const aiAnalysisModalTitle = document.getElementById('ai-analysis-modal-title');
        const aiAnalysisModalBody = document.getElementById('ai-analysis-modal-body');
        const closeAiAnalysisModalBtn = document.getElementById('close-ai-analysis-modal');
        const okAiAnalysisModalBtn = document.getElementById('ok-ai-analysis-modal-btn');
        const financialGoalsHeader = document.getElementById('financial-goals-header');
        const financialGoalsContent = document.getElementById('financial-goals-content');
        const financialGoalsArrow = document.getElementById('financial-goals-arrow');
        const addFinancialGoalForm = document.getElementById('add-financial-goal-form');
        const financialGoalsList = document.getElementById('financial-goals-list');
        const noFinancialGoalsMessage = document.getElementById('no-financial-goals-message');
        const addGoalAiPlanBtn = document.getElementById('add-goal-ai-plan-btn');
        const addGoalAiPlanSpinner = document.getElementById('add-goal-ai-plan-spinner');
        const aiGoalPlanModal = document.getElementById('ai-goal-plan-modal');
        const aiGoalPlanModalTitle = document.getElementById('ai-goal-plan-modal-title');
        const aiGoalPlanModalBody = document.getElementById('ai-goal-plan-modal-body');
        const closeAiGoalPlanModalBtn = document.getElementById('close-ai-goal-plan-modal');
        const okAiGoalPlanModalBtn = document.getElementById('ok-ai-goal-plan-modal-btn');


        // --- Funções Utilitárias ---
        const showFeedback = (message, type) => {
            feedbackMessageEl.textContent = message;
            feedbackMessageEl.classList.remove('hidden', 'feedback-success', 'feedback-error', 'feedback-info');
            feedbackMessageEl.classList.add(`feedback-${type}`);
            feedbackMessageEl.style.display = 'block'; 
            setTimeout(() => {
                if (feedbackMessageEl.textContent === message) { 
                   feedbackMessageEl.style.display = 'none'; 
                }
            }, 7000); 
        };

        const formatCurrency = (value) => {
            return new Intl.NumberFormat('pt-BR', {
                style: 'currency',
                currency: 'BRL'
            }).format(value);
        };

        const generateUniqueId = () => '_' + Math.random().toString(36).substr(2, 9);

        // --- Funções para adicionar Event Listeners ---
        const addDeleteListeners = () => {
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.onclick = (e) => {
                    const id = e.currentTarget.dataset.id;
                    const type = e.currentTarget.dataset.type;
                    performDelete(id, type); 
                };
            });
        };

        const addPayTransactionListeners = () => {
            document.querySelectorAll('.pay-transaction-btn').forEach(button => {
                button.onclick = (e) => {
                    const id = e.currentTarget.dataset.id;
                    markTransactionAsPaid(id);
                };
            });
        };

        const addEditTransactionListeners = () => {
            document.querySelectorAll('.edit-transaction-btn').forEach(button => {
                button.onclick = (e) => {
                    const id = e.currentTarget.dataset.id;
                    openEditModal(id);
                };
            });
        };

        // --- Persistência de Dados (localStorage) ---
        const loadData = () => {
            const storedAccounts = localStorage.getItem('financialAccounts');
            if (storedAccounts) accounts = JSON.parse(storedAccounts);
            
            const storedCreditCards = localStorage.getItem('financialCreditCards');
            if (storedCreditCards) creditCards = JSON.parse(storedCreditCards);
            
            const storedTransactions = localStorage.getItem('financialFinancialTransactions');
            if (storedTransactions) transactions = JSON.parse(storedTransactions);
            
            const storedCategories = localStorage.getItem('financialCategories');
            if (storedCategories) categories = JSON.parse(storedCategories);

            const storedFinancialGoals = localStorage.getItem('financialGoals'); 
            if (storedFinancialGoals) financialGoals = JSON.parse(storedFinancialGoals);


            renderAccounts();
            renderCreditCards();
            populateAccountSelects();
            populateCategorySelect(); 
            populateCategorySelect(editCategorySelect); 
            renderTransactions();
            renderFinancialGoals(); 
            updateSummary(); 
            renderMonthlySummary();
            renderDetailedCardBills();
            checkCreditCardDueDates(); 
        };

        const saveAccounts = () => localStorage.setItem('financialAccounts', JSON.stringify(accounts));
        const saveCreditCards = () => localStorage.setItem('financialCreditCards', JSON.stringify(creditCards));
        const saveTransactions = () => localStorage.setItem('financialFinancialTransactions', JSON.stringify(transactions));
        const saveCategories = () => localStorage.setItem('financialCategories', JSON.stringify(categories));
        const saveFinancialGoals = () => localStorage.setItem('financialGoals', JSON.stringify(financialGoals)); 


        // --- Gerenciamento de Contas e Cartões de Crédito ---
        accountTypeSelect.addEventListener('change', () => {
            if (accountTypeSelect.value === 'overdraft') {
                initialValueLabel.textContent = 'Limite (R$)';
                initialBalanceInput.placeholder = 'Limite (R$)';
            } else { 
                initialValueLabel.textContent = 'Saldo Inicial (R$)';
                initialBalanceInput.placeholder = 'Saldo Inicial (R$)';
            }
        });

        addAccountForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const name = document.getElementById('account-name').value.trim();
            const type = document.getElementById('account-type').value;
            const initialValue = parseFloat(initialBalanceInput.value) || 0; 

            let newAccount;
            if (type === 'overdraft') {
                newAccount = { id: generateUniqueId(), name, type, balance: 0, limit: initialValue };
            } else { 
                newAccount = { id: generateUniqueId(), name, type, balance: initialValue, limit: 0 };
            }

            if (name) {
                accounts.push(newAccount);
                saveAccounts();
                renderAccounts();
                populateAccountSelects();
                updateSummary();
                addAccountForm.reset();
                initialValueLabel.textContent = 'Saldo Inicial (R$)';
                initialBalanceInput.placeholder = 'Saldo Inicial (R$)';
                showFeedback('Conta adicionada com sucesso!', 'success');
            } else {
                showFeedback('Por favor, insira um nome para a conta.', 'error');
            }
        });

        addCreditCardForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const name = document.getElementById('card-name').value.trim();
            const limit = parseFloat(document.getElementById('card-limit').value) || 0;
            const dueDay = parseInt(cardDueDayInput.value);

            if (name && limit > 0 && dueDay >= 1 && dueDay <= 31) {
                const newCard = { id: generateUniqueId(), name, limit, availableLimit: limit, currentBillAmount: 0, dueDay };
                creditCards.push(newCard);
                saveCreditCards();
                renderCreditCards();
                populateAccountSelects();
                addCreditCardForm.reset();
                showFeedback('Cartão de crédito adicionado com sucesso!', 'success');
            } else {
                showFeedback('Por favor, preencha todos os campos do cartão de crédito corretamente.', 'error');
            }
        });

        const renderAccounts = () => {
            accountsList.innerHTML = '';
            if (accounts.length === 0) {
                accountsList.innerHTML = '<li class="p-4 text-gray-500 text-center">Nenhuma conta adicionada ainda.</li>';
                return;
            }
            accounts.forEach(account => {
                const li = document.createElement('li');
                li.className = 'p-4 flex justify-between items-center bg-white hover:bg-gray-50';
                let accountDetailsHtml = '';
                if (account.type === 'overdraft') {
                    accountDetailsHtml = `
                        <span class="font-semibold text-gray-800">${account.name}</span>
                        <span class="text-sm text-gray-500 ml-2">(Cheque Especial)</span>
                        <p class="text-gray-600 text-sm">Limite: <span class="font-bold">${formatCurrency(account.limit)}</span></p>
                        <p class="text-gray-600 text-sm">Utilizado: <span class="font-bold">${formatCurrency(Math.abs(account.balance))}</span></p>
                        <p class="text-gray-600 text-sm">Disponível: <span class="font-bold">${formatCurrency(account.limit + account.balance)}</span></p>`;
                } else { 
                    accountDetailsHtml = `
                        <span class="font-semibold text-gray-800">${account.name}</span>
                        <span class="text-sm text-gray-500 ml-2">(Dinheiro)</span>
                        <p class="text-gray-600 text-sm">Saldo: <span class="font-bold">${formatCurrency(account.balance)}</span></p>`;
                }
                li.innerHTML = `<div>${accountDetailsHtml}</div>
                    <button data-id="${account.id}" data-type="account" class="delete-btn text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-100 transition duration-150 ease-in-out">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>`;
                accountsList.appendChild(li);
            });
            addDeleteListeners();
        };

        const renderCreditCards = () => {
            creditCardsList.innerHTML = '';
            if (creditCards.length === 0) {
                creditCardsList.innerHTML = '<li class="p-4 text-gray-500 text-center">Nenhum cartão de crédito adicionado ainda.</li>';
                return;
            }
            creditCards.forEach(card => {
                let currentMonthBill = transactions.reduce((sum, t) => {
                    const transactionDate = new Date(t.date);
                    if (t.accountId === card.id && t.type === 'despesa' && !t.isPaid &&
                        transactionDate.getMonth() === currentMonth && transactionDate.getFullYear() === currentYear) {
                        return sum + t.value;
                    }
                    return sum;
                }, 0);
                const li = document.createElement('li');
                li.className = 'p-4 flex justify-between items-center bg-white hover:bg-gray-50';
                li.innerHTML = `
                    <div>
                        <span class="font-semibold text-gray-800">${card.name}</span>
                        <span class="text-sm text-gray-500 ml-2">(Crédito)</span>
                        <p class="text-gray-600 text-sm">Limite: <span class="font-bold">${formatCurrency(card.limit)}</span></p>
                        <p class="text-gray-600 text-sm">Limite Disponível: <span class="font-bold">${formatCurrency(card.availableLimit)}</span></p>
                        <p class="text-gray-600 text-sm">Fatura Atual: <span class="font-bold">${formatCurrency(currentMonthBill)}</span></p>
                        <p class="text-gray-600 text-sm">Vencimento: Dia ${card.dueDay}</p>
                    </div>
                    <button data-id="${card.id}" data-type="creditCard" class="delete-btn text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-100 transition duration-150 ease-in-out">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>`;
                creditCardsList.appendChild(li);
            });
            addDeleteListeners();
        };

        const populateAccountSelects = (targetSelect = accountSelect) => { 
            targetSelect.innerHTML = ''; 
            
            const noLinkOption = document.createElement('option');
            noLinkOption.value = ""; 
            noLinkOption.textContent = targetSelect === accountSelect ? "Não Vincular / Geral" : "Selecione"; 
            targetSelect.appendChild(noLinkOption);

            accounts.forEach(account => {
                const option = document.createElement('option');
                option.value = account.id;
                const accountTypeText = account.type === 'overdraft' ? 'Cheque Especial' : 'Dinheiro';
                option.textContent = `${account.name} (${accountTypeText})`;
                targetSelect.appendChild(option);
            });
            creditCards.forEach(card => {
                const option = document.createElement('option');
                option.value = card.id;
                option.textContent = `${card.name} (Cartão de Crédito)`;
                targetSelect.appendChild(option);
            });
            if (!targetSelect.value && targetSelect === accountSelect) { 
                targetSelect.value = "";
            }
        };
        
        populateAccountSelects(); 

        const populateCategorySelect = (selectElement = categorySelect) => { 
            const currentCategoryValue = selectElement.value;
            selectElement.innerHTML = ''; 
            
            if (selectElement === categorySelect) {
                 const placeholderOption = document.createElement('option');
                 placeholderOption.value = "";
                 placeholderOption.textContent = "Selecione uma categoria";
                 placeholderOption.disabled = true;
                 placeholderOption.selected = !currentCategoryValue; 
                 selectElement.appendChild(placeholderOption);
            }

            categories.sort((a,b) => a.localeCompare(b)).forEach(cat => { 
                const option = document.createElement('option');
                option.value = cat; option.textContent = cat;
                selectElement.appendChild(option);
            });
            const newOption = document.createElement('option');
            newOption.value = 'nova-categoria'; 
            newOption.textContent = 'Adicionar Nova Categoria...';
            selectElement.appendChild(newOption);

            if (categories.includes(currentCategoryValue)) {
                selectElement.value = currentCategoryValue;
            } else if (currentCategoryValue === 'nova-categoria' && selectElement === categorySelect) { 
                 selectElement.value = 'nova-categoria'; 
            } else if (!currentCategoryValue && selectElement !== categorySelect) { 
                if(categories.length > 0 && selectElement.options.length > (selectElement === categorySelect ? 1:0) ) { 
                    selectElement.value = categories[0];
                }
            }
        };
        
        populateCategorySelect(); 

        categorySelect.addEventListener('change', () => {
            if (categorySelect.value === 'nova-categoria') {
                newCategoryInput.classList.remove('hidden');
                newCategoryInput.focus(); newCategoryInput.value = ''; 
            } else {
                newCategoryInput.classList.add('hidden'); newCategoryInput.value = ''; 
            }
        });

        // --- Gerenciamento de Transações ---
        transactionForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const date = document.getElementById('date').value;
            const description = document.getElementById('description').value.trim();
            const value = parseFloat(document.getElementById('value').value);
            let type = document.getElementById('type').value; 
            const accountId = document.getElementById('account-select').value; 
            const installments = parseInt(installmentsInput.value) || 1;
            const installmentsPaid = parseInt(installmentsPaidInput.value) || 0; 

            let category;
            if (categorySelect.value === 'nova-categoria') {
                category = newCategoryInput.value.trim();
                if (category && !categories.includes(category)) {
                    categories.push(category); saveCategories(); 
                    populateCategorySelect(); 
                    populateCategorySelect(editCategorySelect); 
                    categorySelect.value = category; 
                } else if (categories.includes(category)) { 
                     categorySelect.value = category; 
                     newCategoryInput.classList.add('hidden'); newCategoryInput.value = '';
                } else if (!category) { 
                    showFeedback('Por favor, insira um nome para a nova categoria ou selecione uma existente.', 'error'); return;
                }
            } else { category = categorySelect.value; }

            if (!date || !description || isNaN(value) || value <= 0 || !type || !category ) {
                showFeedback('Por favor, preencha todos os campos da transação (exceto Conta/Cartão que é opcional) com valores válidos (valor > 0).', 'error'); return;
            }
            if (installmentsPaid > installments || installmentsPaid < 0) { 
                showFeedback('O número de parcelas pagas é inválido ou excede o total.', 'error'); return;
            }

            const account = accountId ? accounts.find(acc => acc.id === accountId) : null;
            const creditCard = accountId ? creditCards.find(card => card.id === accountId) : null;
            const isCreditCardTransaction = !!creditCard;
            let transactionsToAdd = [];
            const originalGroupId = generateUniqueId(); 

            let fundamentalType = 'despesa'; 
            if (type === 'receita' || type === 'pix_recebido') {
                fundamentalType = 'receita';
            }


            if (installments > 1 && (type === 'despesa' || type === 'pix_enviado' || type === 'saque')) { 
                const installmentValue = parseFloat((value / installments).toFixed(2));
                let sumOfInstallments = 0;
                for (let i = 0; i < installments; i++) {
                    let currentInstallmentValue = installmentValue;
                    if (i === installments - 1) { 
                        currentInstallmentValue = parseFloat((value - sumOfInstallments).toFixed(2));
                    }
                    sumOfInstallments += currentInstallmentValue;

                    const transactionDate = new Date(date);
                    transactionDate.setMonth(transactionDate.getMonth() + i); 
                    transactionsToAdd.push({
                        id: generateUniqueId(), date: transactionDate.toISOString().split('T')[0], description: `${description} (${i + 1}/${installments})`, 
                        value: currentInstallmentValue, 
                        type: type, 
                        fundamentalType: fundamentalType, 
                        category, accountId: accountId || null, 
                        isCreditCard: isCreditCardTransaction,
                        installments: `${i + 1}/${installments}`, isPaid: (i + 1) <= installmentsPaid,
                        originalGroupId 
                    });
                }
            } else { 
                transactionsToAdd.push({
                    id: generateUniqueId(), date, description, value, 
                    type: type, 
                    fundamentalType: fundamentalType, 
                    category, accountId: accountId || null, 
                    isCreditCard: isCreditCardTransaction, installments: '1/1', isPaid: installmentsPaid >= 1,
                    originalGroupId
                });
            }

            let transactionAddedSuccessfully = true;
            const tempAccounts = JSON.parse(JSON.stringify(accounts)); 
            const tempCreditCards = JSON.parse(JSON.stringify(creditCards));

            for (const newTransaction of transactionsToAdd) {
                if (newTransaction.accountId) { 
                    let targetAccountOrCard;
                    if (newTransaction.isCreditCard) {
                        targetAccountOrCard = tempCreditCards.find(c => c.id === newTransaction.accountId);
                        if (targetAccountOrCard) {
                             if (newTransaction.fundamentalType === 'despesa') targetAccountOrCard.availableLimit -= newTransaction.value;
                             else targetAccountOrCard.availableLimit += newTransaction.value; 
                        }
                    } else { 
                        targetAccountOrCard = tempAccounts.find(a => a.id === newTransaction.accountId); 
                         if (targetAccountOrCard) {
                            if (newTransaction.isPaid) { 
                                if (newTransaction.fundamentalType === 'despesa') { 
                                    if (targetAccountOrCard.type === 'overdraft' && (targetAccountOrCard.balance - newTransaction.value < -targetAccountOrCard.limit)) {
                                        showFeedback(`Transação de ${formatCurrency(newTransaction.value)} para ${targetAccountOrCard.name} excede limite de cheque especial.`, 'error');
                                        transactionAddedSuccessfully = false; break; 
                                    }
                                    targetAccountOrCard.balance -= newTransaction.value;
                                } else { 
                                    targetAccountOrCard.balance += newTransaction.value;
                                }
                            }
                        }
                    }
                    if (!targetAccountOrCard) { 
                        showFeedback('Conta/Cartão vinculado não encontrado. A transação será salva como não vinculada.', 'info');
                        newTransaction.accountId = null; 
                        newTransaction.isCreditCard = false;
                    }
                }
            }

            if (!transactionAddedSuccessfully) {
                return; 
            }

            if (accountId) { 
                accounts = tempAccounts;
                creditCards = tempCreditCards;
            }
            transactions.push(...transactionsToAdd); 

            saveTransactions(); saveAccounts(); saveCreditCards();
            renderTransactions(); updateSummary(); renderDetailedCardBills(); checkCreditCardDueDates(); 
            transactionForm.reset(); 
            installmentsInput.value = 1; 
            installmentsPaidInput.value = 0; 
            accountSelect.value = ""; 
            newCategoryInput.classList.add('hidden'); 
            populateCategorySelect(); 
            showFeedback('Transação(ões) adicionada(s) com sucesso!', 'success');
        });

        const renderTransactions = () => {
            transactionList.innerHTML = '';
            const beginningOfCurrentMonth = new Date(currentYear, currentMonth, 1);
            beginningOfCurrentMonth.setHours(0,0,0,0); 

            const filteredTransactions = transactions.filter(t => {
                const transactionDate = new Date(t.date);
                transactionDate.setHours(0,0,0,0); 
                const isInCurrentMonthAndYear = transactionDate.getMonth() === currentMonth && transactionDate.getFullYear() === currentYear;
                const isPendingFromPreviousMonth = transactionDate < beginningOfCurrentMonth && !t.isPaid;
                return isInCurrentMonthAndYear || isPendingFromPreviousMonth;
            }).sort((a, b) => new Date(a.date) - new Date(b.date)); 

            if (filteredTransactions.length === 0) {
                noTransactionsMessage.classList.remove('hidden'); return;
            } else {
                noTransactionsMessage.classList.add('hidden');
            }

            filteredTransactions.forEach(transaction => {
                const tr = document.createElement('tr');
                let rowClass = 'bg-white hover:bg-gray-50';
                const transactionDate = new Date(transaction.date);
                transactionDate.setHours(0,0,0,0);

                if (transaction.isPaid) {
                    rowClass += ' paid-transaction';
                } else if (transactionDate < beginningOfCurrentMonth) {
                    rowClass += ' pending-previous-month'; 
                }
                tr.className = rowClass;

                const accountOrCardName = transaction.accountId 
                    ? (transaction.isCreditCard
                        ? creditCards.find(card => card.id === transaction.accountId)?.name || 'Cartão Desconhecido'
                        : accounts.find(acc => acc.id === transaction.accountId)?.name || 'Conta Desconhecida')
                    : 'Não Vinculada'; 

                const textStyle = transaction.isPaid ? 'text-gray-500' : (transactionDate < beginningOfCurrentMonth ? 'text-gray-900 font-semibold' : 'text-gray-900 font-semibold');
                
                let typeDisplay = transaction.type;
                let valueColorClass = 'text-gray-800'; 
                if (transaction.fundamentalType === 'receita') { 
                    valueColorClass = 'text-green-600';
                    if (transaction.type === 'pix_recebido') typeDisplay = 'PIX Recebido';
                    else if (transaction.type === 'receita') typeDisplay = 'Receita';
                } else if (transaction.fundamentalType === 'despesa') {
                    valueColorClass = transaction.isPaid ? 'text-red-500' : 'text-red-700 font-bold';
                    if (transaction.type === 'saque') typeDisplay = 'Saque';
                    else if (transaction.type === 'pix_enviado') typeDisplay = 'PIX Enviado';
                    else if (transaction.type === 'despesa') typeDisplay = 'Despesa';
                }


                const statusStyle = transaction.isPaid ? 'text-green-600' : 'text-red-700 font-bold';

                tr.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${textStyle}">${new Date(transaction.date).toLocaleDateString('pt-BR')}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${textStyle}">${transaction.description}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${valueColorClass}">${formatCurrency(transaction.value)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${textStyle}">${typeDisplay}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${textStyle}">${transaction.category}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${textStyle}">${accountOrCardName}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${textStyle}">${transaction.installments}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm ${statusStyle}">${transaction.isPaid ? 'Pago' : 'Não Pago'}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        ${!transaction.isPaid ? `<button data-id="${transaction.id}" class="pay-transaction-btn text-blue-600 hover:text-blue-900 mr-2 p-2 rounded-full hover:bg-blue-100"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></button>` : ''}
                        <button data-id="${transaction.id}" class="edit-transaction-btn text-yellow-600 hover:text-yellow-900 mr-2 p-2 rounded-full hover:bg-yellow-100"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                        <button data-id="${transaction.id}" data-type="transaction" class="delete-btn text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-100"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </td>`;
                transactionList.appendChild(tr);
            });
            addDeleteListeners(); addPayTransactionListeners(); addEditTransactionListeners();
        };

        const performDelete = (id, type) => {
            if (type === 'account') {
                if (transactions.some(t => t.accountId === id)) {
                    showFeedback('Não é possível excluir conta com transações. Exclua as transações primeiro.', 'error'); return;
                }
                accounts = accounts.filter(acc => acc.id !== id); saveAccounts();
                renderAccounts(); populateAccountSelects(); updateSummary();
                showFeedback('Conta excluída!', 'success');
            } else if (type === 'creditCard') {
                if (transactions.some(t => t.accountId === id)) {
                    showFeedback('Não é possível excluir cartão com transações. Exclua as transações primeiro.', 'error'); return;
                }
                creditCards = creditCards.filter(card => card.id !== id); saveCreditCards();
                renderCreditCards(); populateAccountSelects(); updateSummary();
                showFeedback('Cartão excluído!', 'success');
            } else if (type === 'transaction') {
                const deletedTransactionIndex = transactions.findIndex(t => t.id === id);
                if (deletedTransactionIndex > -1) {
                    const deletedTransaction = transactions[deletedTransactionIndex];
                    if (deletedTransaction.accountId) { 
                        if (deletedTransaction.isCreditCard) {
                            const card = creditCards.find(c => c.id === deletedTransaction.accountId);
                            if (card) {
                                if (deletedTransaction.fundamentalType === 'despesa') card.availableLimit += deletedTransaction.value;
                                else card.availableLimit -= deletedTransaction.value;
                            }
                        } else { 
                            const account = accounts.find(acc => acc.id === deletedTransaction.accountId);
                            if (account && deletedTransaction.isPaid) { 
                                if (deletedTransaction.fundamentalType === 'despesa') account.balance += deletedTransaction.value;
                                else account.balance -= deletedTransaction.value;
                            }
                        }
                    }
                    transactions.splice(deletedTransactionIndex, 1); 
                    saveTransactions(); saveAccounts(); saveCreditCards();
                    renderTransactions(); updateSummary(); renderMonthlySummary(); renderDetailedCardBills(); checkCreditCardDueDates();
                    showFeedback('Transação excluída!', 'success');
                }
            }
        };

        const markTransactionAsPaid = (transactionId) => {
            const transaction = transactions.find(t => t.id === transactionId);
            if (transaction && !transaction.isPaid) {
                const previouslyPaid = transaction.isPaid; 
                transaction.isPaid = true; 
                
                if (!previouslyPaid && transaction.accountId && !transaction.isCreditCard) { 
                    const account = accounts.find(acc => acc.id === transaction.accountId);
                    if (account) {
                        if (transaction.fundamentalType === 'despesa') {
                             if (account.type === 'overdraft' && (account.balance - transaction.value < -account.limit)) {
                                showFeedback(`Pagamento de ${formatCurrency(transaction.value)} para ${account.name} excede limite. Marcada como paga, mas ajuste o saldo se necessário.`, 'error');
                            } else {
                                account.balance -= transaction.value;
                            }
                        } else { 
                            account.balance += transaction.value;
                        }
                        saveAccounts();
                    }
                }
                saveTransactions();
                renderTransactions(); updateSummary(); renderMonthlySummary(); renderDetailedCardBills(); checkCreditCardDueDates();
                showFeedback('Transação marcada como paga!', 'success');
            } else if (transaction && transaction.isPaid) {
                showFeedback('Esta transação já está paga.', 'info');
            }
        };

        // --- Funções do Modal de Edição ---
        const openEditModal = (transactionId) => {
            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) { showFeedback('Transação não encontrada.', 'error'); return; }
            
            editTransactionIdInput.value = transaction.id;
            editDateInput.value = transaction.date; 
            editDescriptionInput.value = transaction.description; 
            editValueInput.value = transaction.value.toFixed(2); 
            
            populateCategorySelect(editCategorySelect); 
            editCategorySelect.value = transaction.category; 
            editNewCategoryInput.classList.add('hidden'); 
            editNewCategoryInput.value = '';

            const [currentPaid, totalInstallments] = transaction.installments.split('/').map(Number);
            editInstallmentsTotalInput.value = totalInstallments; 
            editInstallmentsTotalInput.readOnly = true; 
            editInstallmentsTotalInput.classList.add('bg-gray-100', 'cursor-not-allowed');
            editInstallmentsPaidInput.value = currentPaid; 
            editInstallmentsPaidInput.max = totalInstallments; 

            editDateInput.readOnly = false; 
            editDescriptionInput.readOnly = false;
            editDescriptionInput.classList.remove('bg-gray-100', 'cursor-not-allowed');
            editValueInput.readOnly = false;
            editValueInput.classList.remove('bg-gray-100', 'cursor-not-allowed');

            editTransactionModal.classList.remove('hidden');
        };
        
        editCategorySelect.addEventListener('change', () => {
            if (editCategorySelect.value === 'nova-categoria') {
                editNewCategoryInput.classList.remove('hidden');
                editNewCategoryInput.focus();
            } else {
                editNewCategoryInput.classList.add('hidden');
                editNewCategoryInput.value = '';
            }
        });

        const closeEditModal = () => {
            editTransactionModal.classList.add('hidden');
            editDescriptionInput.readOnly = true;
            editDescriptionInput.classList.add('bg-gray-100', 'cursor-not-allowed');
            editValueInput.readOnly = true;
            editValueInput.classList.add('bg-gray-100', 'cursor-not-allowed');
            editInstallmentsTotalInput.readOnly = true;
            editInstallmentsTotalInput.classList.add('bg-gray-100', 'cursor-not-allowed');
            editDateInput.readOnly = true; 
            editNewCategoryInput.classList.add('hidden'); 
        };
        closeEditModalBtn.addEventListener('click', closeEditModal);
        cancelEditTransactionBtn.addEventListener('click', closeEditModal);

        saveEditTransactionBtn.addEventListener('click', () => {
            const transactionId = editTransactionIdInput.value;
            const newDate = editDateInput.value;
            const newDescription = editDescriptionInput.value.trim();
            const newValue = parseFloat(editValueInput.value);
            const newInstallmentsPaid = parseInt(editInstallmentsPaidInput.value);
            
            let newCategory = editCategorySelect.value;
            if (newCategory === 'nova-categoria') {
                const typedNewCategory = editNewCategoryInput.value.trim();
                if (typedNewCategory) {
                    if (!categories.includes(typedNewCategory)) {
                        categories.push(typedNewCategory);
                        saveCategories();
                        populateCategorySelect(); 
                        populateCategorySelect(editCategorySelect); 
                    }
                    newCategory = typedNewCategory;
                } else {
                    showFeedback('Nome da nova categoria não pode ser vazio.', 'error'); return;
                }
            }


            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) {
                showFeedback('Erro: Transação não encontrada.', 'error'); closeEditModal(); return;
            }
            const totalInstallments = parseInt(transaction.installments.split('/')[1]); 

            if (!newDate) { showFeedback('Data não pode ser vazia.', 'error'); return; }
            if (!newDescription) { showFeedback('Descrição não pode ser vazia.', 'error'); return; }
            if (isNaN(newValue) || newValue <= 0) { showFeedback('Valor inválido. Deve ser maior que zero.', 'error'); return; }
            if (isNaN(newInstallmentsPaid) || newInstallmentsPaid < 0 || newInstallmentsPaid > totalInstallments) {
                showFeedback('Número de parcelas pagas inválido.', 'error'); return;
            }

            const oldValue = transaction.value;
            const oldIsPaid = transaction.isPaid;
            const fundamentalType = transaction.fundamentalType; 

            if (transaction.accountId) { 
                if (!transaction.isCreditCard && oldIsPaid) {
                    const account = accounts.find(acc => acc.id === transaction.accountId);
                    if (account) {
                        if (fundamentalType === 'despesa') account.balance += oldValue;
                        else account.balance -= oldValue;
                    }
                }
                if (transaction.isCreditCard) {
                     const card = creditCards.find(c => c.id === transaction.accountId);
                     if (card) {
                        if (fundamentalType === 'despesa') card.availableLimit += oldValue;
                        else card.availableLimit -= oldValue; 
                     }
                }
            }

            transaction.date = newDate;
            transaction.description = newDescription;
            transaction.value = newValue;
            transaction.category = newCategory;
            transaction.installments = `${newInstallmentsPaid}/${totalInstallments}`;
            transaction.isPaid = newInstallmentsPaid >= totalInstallments;

            if (transaction.accountId) { 
                if (!transaction.isCreditCard && transaction.isPaid) {
                    const account = accounts.find(acc => acc.id === transaction.accountId);
                    if (account) {
                        if (fundamentalType === 'despesa') account.balance -= transaction.value;
                        else account.balance += transaction.value;
                    }
                }
                if (transaction.isCreditCard) {
                    const card = creditCards.find(c => c.id === transaction.accountId);
                    if (card) {
                        if (fundamentalType === 'despesa') card.availableLimit -= transaction.value;
                        else card.availableLimit += transaction.value; 
                    }
                }
            }
            
            saveTransactions(); saveAccounts(); saveCreditCards();
            renderTransactions(); updateSummary(); renderMonthlySummary(); 
            renderDetailedCardBills(); checkCreditCardDueDates();
            showFeedback('Transação atualizada com sucesso!', 'success'); 
            closeEditModal();
        });

        // --- Resumo e Cálculos ---
        const updateSummary = () => {
            let totalPoderDeCompra = 0; 
            accounts.forEach(account => {
                if (account.type === 'cash') totalPoderDeCompra += account.balance;
                else if (account.type === 'overdraft') totalPoderDeCompra += (account.limit + account.balance); 
            });
            creditCards.forEach(card => totalPoderDeCompra += card.availableLimit); 

            totalReceitasEl.textContent = formatCurrency(totalPoderDeCompra);

            const totalDespesasMesAtualText = totalDespesasEl.textContent || "R$ 0,00";
            const totalDespesasMesAtual = parseFloat(totalDespesasMesAtualText.replace('R$', '').replace(/\./g, '').replace(',', '.')) || 0;
            
            const saldoConsolidado = totalPoderDeCompra - totalDespesasMesAtual; 
            saldoAtualEl.textContent = formatCurrency(saldoConsolidado);

            let totalFaturasCartaoMesAtual = 0;
            creditCards.forEach(card => {
                const currentMonthBill = transactions.reduce((sum, t) => {
                    const tDate = new Date(t.date);
                    if (t.accountId === card.id && t.isCreditCard && t.fundamentalType === 'despesa' && !t.isPaid &&
                        tDate.getMonth() === currentMonth && tDate.getFullYear() === currentYear) {
                        return sum + t.value;
                    }
                    return sum;
                }, 0);
                totalFaturasCartaoMesAtual += currentMonthBill;
            });
            totalCardBillsEl.textContent = formatCurrency(totalFaturasCartaoMesAtual);

            saldoAtualEl.className = `text-2xl font-bold ${saldoConsolidado >= 0 ? 'text-green-700' : 'text-red-700'}`;
        };
        
        // --- Navegação e Resumo por Mês ---
        const updateMonthlyDisplay = () => {
            const date = new Date(currentYear, currentMonth);
            currentMonthDisplay.textContent = date.toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' });
        };

        const renderMonthlySummary = () => {
            let monthlyExpensesTotal = 0;
            let monthlyIncomeTotal = 0; 
            const beginningOfCurrentMonth = new Date(currentYear, currentMonth, 1);
            beginningOfCurrentMonth.setHours(0,0,0,0); 

            transactions.forEach(t => {
                const transactionDate = new Date(t.date);
                transactionDate.setHours(0,0,0,0); 
                const isInCurrentMonthAndYear = transactionDate.getMonth() === currentMonth && transactionDate.getFullYear() === currentYear;
                const isPendingFromPreviousMonth = transactionDate < beginningOfCurrentMonth && !t.isPaid;
                
                if (t.fundamentalType === 'despesa' && (isInCurrentMonthAndYear || isPendingFromPreviousMonth)) {
                    monthlyExpensesTotal += t.value;
                } else if (t.fundamentalType === 'receita' && isInCurrentMonthAndYear) { 
                    monthlyIncomeTotal += t.value;
                }
            });
            totalDespesasEl.textContent = formatCurrency(monthlyExpensesTotal);
        };

        prevMonthBtn.addEventListener('click', () => {
            currentMonth--; if (currentMonth < 0) { currentMonth = 11; currentYear--; }
            updateMonthlyDisplay(); renderTransactions(); renderMonthlySummary(); updateSummary();
        });
        nextMonthBtn.addEventListener('click', () => {
            currentMonth++; if (currentMonth > 11) { currentMonth = 0; currentYear++; }
            updateMonthlyDisplay(); renderTransactions(); renderMonthlySummary(); updateSummary();
        });

        // --- Funções de Importação ---
        const finalizeImportProcessing = (parsedTransactions) => {
            fileInput.value = ''; 
            fileInput.disabled = false;
            importFileBtn.disabled = false;

            if (parsedTransactions && parsedTransactions.length > 0) {
                importedTransactionsToReview = parsedTransactions; 
                renderImportedTransactionsForReview();
                importReviewSection.classList.remove('hidden');
            } else {
                 if (!feedbackMessageEl.textContent.includes("Processando") && 
                     !feedbackMessageEl.textContent.includes("Erro") && 
                     (!parsedTransactions || parsedTransactions.length === 0) &&
                     !feedbackMessageEl.textContent.includes("Nenhuma transação encontrada") && 
                     !feedbackMessageEl.textContent.includes("Nenhum texto encontrado") 
                    ) {
                 }
                importReviewSection.classList.add('hidden'); 
            }
        };

        const handleImportError = (error, fileTypeDescription) => {
            console.error(`Erro ao processar arquivo ${fileTypeDescription}:`, error);
            showFeedback(`Erro ao processar arquivo ${fileTypeDescription}. Verifique o console.`, 'error');
            importReviewSection.classList.add('hidden');
            fileInput.value = '';
            fileInput.disabled = false;
            importFileBtn.disabled = false;
        };
        
        const processTextWithAIForTransactions = async (textContent) => {
            if (!textContent || textContent.trim().length < 10) { 
                showFeedback("Texto extraído é muito curto ou inválido para análise pela IA.", "info");
                return [];
            }

            showFeedback("IA está analisando o extrato para identificar transações...", "info");
            
            const accountNames = accounts.map(acc => acc.name);
            const cardNames = creditCards.map(card => card.name);
            const allAccountableNames = [...new Set([...accountNames, ...cardNames])]; 
            
            const prompt = `
                Você é um assistente financeiro especialista em analisar extratos.
                Analise o seguinte texto de um extrato financeiro. Identifique todas as transações individuais que você encontrar.
                Para cada transação, extraia os seguintes campos:
                1.  "data": A data da transação (formato AAAA-MM-DD). Se o ano não estiver presente, assuma o ano corrente (${currentYear}). Se a data não for clara, use a data de hoje (${new Date().toISOString().split('T')[0]}).
                2.  "descricao": Uma descrição clara e concisa da transação.
                3.  "valor": O valor numérico da transação. Use ponto como separador decimal. Se for um débito/saída, represente como um número negativo. Se for um crédito/entrada, como positivo.
                4.  "categoriaSugerida": Sugira a categoria mais apropriada em português do Brasil. Categorias comuns são: ${categories.join(", ")}, Salário, Transferência, Pagamento de Contas. Se não tiver certeza, use "Outros".
                5.  "contaNomeSugerido": Se o texto indicar claramente a origem ou destino da transação em uma conta ou cartão, sugira o nome mais próximo de uma das seguintes opções: ${allAccountableNames.join(", ")}. Se não for claro ou não aplicável, deixe este campo vazio.

                Texto do extrato:
                ---
                ${textContent.substring(0, 15000)} 
                ---
                Retorne o resultado como um array de objetos JSON. Cada objeto deve ter as chaves "data", "descricao", "valor", "categoriaSugerida", "contaNomeSugerido".
                Se não encontrar transações, retorne um array vazio.
                Exemplo de objeto JSON: {"data": "${new Date().toISOString().split('T')[0]}", "descricao": "Pagamento Aluguel", "valor": -1200.00, "categoriaSugerida": "Moradia", "contaNomeSugerido": "Banco Principal"}
            `;
            
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory,
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ]
            };
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API Gemini (processTextWithAIForTransactions):", errorData);
                    throw new Error(`Erro da API: ${response.status} - ${errorData.error?.message || 'Erro desconhecido'}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0].text) {
                    let aiResponseText = result.candidates[0].content.parts[0].text;
                    aiResponseText = aiResponseText.replace(/```json/g, '').replace(/```/g, '').trim();
                    
                    let parsedAITransactions = [];
                    try {
                        parsedAITransactions = JSON.parse(aiResponseText);
                        if (!Array.isArray(parsedAITransactions)) { 
                           try {
                                const wrappedAttempt = JSON.parse(`[${aiResponseText}]`);
                                if (Array.isArray(wrappedAttempt) && typeof wrappedAttempt[0] === 'object') {
                                    parsedAITransactions = wrappedAttempt;
                                } else { throw new Error("Not an array after wrap."); }
                           } catch (wrapError) {
                               console.warn("IA response not array, wrap failed:", aiResponseText, wrapError); parsedAITransactions = [];
                           }
                        }
                    } catch (e) {
                        console.error("Error parsing AI JSON:", e, "\nAI Text:", aiResponseText);
                        showFeedback("IA retornou dados em formato inesperado.", "error"); return [];
                    }

                    const finalTransactions = parsedAITransactions.map(aiTx => {
                        const valorOriginal = parseFloat(aiTx.valor) || 0;
                        const valorAbsoluto = Math.abs(valorOriginal);
                        const tipoFundamental = valorOriginal >= 0 ? 'receita' : 'despesa';
                        
                        let tipoTransacao = tipoFundamental; 
                        const descLower = (aiTx.descricao || "").toLowerCase();
                        if (descLower.includes('pix') && descLower.includes('env')) tipoTransacao = 'pix_enviado';
                        else if (descLower.includes('pix') && descLower.includes('rec')) tipoTransacao = 'pix_recebido';
                        else if (descLower.includes('saque') || descLower.includes('retirada')) tipoTransacao = 'saque';

                        let accountIdToLink = null;
                        let isCreditCardLinked = false;
                        if (aiTx.contaNomeSugerido) {
                            const suggestionLower = aiTx.contaNomeSugerido.toLowerCase();
                            const foundAccount = accounts.find(acc => acc.name.toLowerCase().includes(suggestionLower) || suggestionLower.includes(acc.name.toLowerCase()));
                            if (foundAccount) {
                                accountIdToLink = foundAccount.id;
                            } else {
                                const foundCard = creditCards.find(card => card.name.toLowerCase().includes(suggestionLower) || suggestionLower.includes(card.name.toLowerCase()));
                                if (foundCard) {
                                    accountIdToLink = foundCard.id;
                                    isCreditCardLinked = true;
                                }
                            }
                        }
                        
                        let dataValida = new Date().toISOString().split('T')[0]; 
                        if (aiTx.data) {
                            const parsedDate = new Date(aiTx.data);
                            if (!isNaN(parsedDate.getTime())) { 
                                if (parsedDate.getFullYear() < 1900 || parsedDate.getFullYear() > 2100) { 
                                     const parts = aiTx.data.split('-'); 
                                     if (parts.length === 2) { 
                                         const month = parseInt(parts[0]) -1;
                                         const day = parseInt(parts[1]);
                                         if (!isNaN(month) && !isNaN(day)) {
                                             const tempDate = new Date(currentYear, month, day);
                                             if(!isNaN(tempDate.getTime())) dataValida = tempDate.toISOString().split('T')[0];
                                         }
                                     } else if (parts.length === 3 && aiTx.data.length === 8 && !aiTx.data.includes('-')) { 
                                         dataValida = `${aiTx.data.substring(0,4)}-${aiTx.data.substring(4,6)}-${aiTx.data.substring(6,8)}`;
                                     }
                                } else {
                                   dataValida = parsedDate.toISOString().split('T')[0];
                                }
                            }
                        }

                        return {
                            id: generateUniqueId(), date: dataValida,
                            description: aiTx.descricao || "Descrição não identificada",
                            value: valorAbsoluto, type: tipoTransacao, fundamentalType: tipoFundamental,
                            category: categories.includes(aiTx.categoriaSugerida) ? aiTx.categoriaSugerida : "Outros",
                            accountId: accountIdToLink, isCreditCard: isCreditCardLinked,
                            installments: '1/1', isPaid: true,
                            fundamentalTypeOriginalSignal: valorOriginal >= 0 ? 1 : -1 
                        };
                    }).filter(tx => tx.value > 0); 

                    showFeedback(`IA processou o extrato. ${finalTransactions.length} transações prontas para revisão.`, "success");
                    return finalTransactions;
                } else {
                     console.warn("Resposta da API Gemini (processTextWithAIForTransactions) não continha dados válidos:", result);
                    showFeedback("IA não conseguiu extrair transações do texto.", "info");
                    return [];
                }

            } catch (error) {
                console.error("Erro ao chamar API Gemini (processTextWithAIForTransactions):", error);
                showFeedback(`Erro ao processar texto com IA: ${error.message}`, "error");
                return [];
            }
        };
        
        const parseOFX = (ofxContent) => {
            const parsedTransactions = [];
            const transactionRegex = /<STMTTRN>([\s\S]*?)<\/STMTTRN>/g;
            let match;
            while ((match = transactionRegex.exec(ofxContent)) !== null) {
                const transactionBlock = match[1];
                const dateMatch = /<DTPOSTED>(\d{8})/.exec(transactionBlock);
                const descriptionMatch = /<MEMO>([\s\S]*?)<\/(MEMO|NAME)>/.exec(transactionBlock);
                const valueMatch = /<TRNAMT>([+\-]?[\d,.]+)/.exec(transactionBlock);
                const typeMatch = /<TRNTYPE>(DEBIT|CREDIT)/i.exec(transactionBlock);

                if (dateMatch && descriptionMatch && valueMatch) {
                    const dateStr = dateMatch[1];
                    const formattedDate = `${dateStr.substring(0, 4)}-${dateStr.substring(4, 6)}-${dateStr.substring(6, 8)}`;
                    const description = descriptionMatch[1].trim();
                    const value = parseFloat(valueMatch[1].replace(',', '.')); 
                    let transactionType = value < 0 ? 'despesa' : 'receita'; 
                    if (typeMatch) { 
                        transactionType = typeMatch[1].toUpperCase() === 'CREDIT' ? 'receita' : 'despesa';
                    }
                    let fundamentalType = transactionType; 

                    if (!isNaN(value)) {
                         parsedTransactions.push({
                            id: generateUniqueId(), date: formattedDate, description, 
                            value: Math.abs(value), type: transactionType, fundamentalType,
                            category: 'Importado OFX', 
                            accountId: '', isCreditCard: false, installments: '1/1', isPaid: true 
                        });
                    }
                }
            }
            if (parsedTransactions.length === 0 && ofxContent.length > 100) showFeedback("Nenhuma transação encontrada no arquivo OFX ou formato inválido.", 'info');
            else if (parsedTransactions.length > 0) showFeedback(`${parsedTransactions.length} transações OFX carregadas para revisão.`, 'success');
            return parsedTransactions;
        };

        const parseExcelCsv = (data, fileExtension, isTextData = false) => {
            const parsedTransactions = [];
            try {
                const workbook = XLSX.read(data, { type: isTextData ? 'string' : 'binary', cellDates: true }); 
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const json = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: "" }); 

                if (json.length === 0) {
                    showFeedback(`Arquivo ${fileExtension} vazio ou não pôde ser lido.`, 'info');
                    return parsedTransactions;
                }

                let headerRowIndex = -1;
                let dateCol = -1, descCol = -1, valueCol = -1, typeCol = -1;
                const headerKeywords = {
                    date: ['data', 'date', 'dt.'],
                    desc: ['descricao', 'descrição', 'description', 'histórico', 'historico', 'memo', 'lançamento', 'lancamento'],
                    value: ['valor', 'value', 'montante', 'amount', 'crédito', 'credito', 'débito', 'debito'], 
                    type: ['tipo', 'type', 'natureza', 't'] 
                };

                for (let i = 0; i < Math.min(json.length, 15); i++) { 
                    const row = json[i];
                    if (Array.isArray(row) && row.some(cell => String(cell || '').trim() !== '')) { 
                        const lowerCaseRow = row.map(cell => String(cell || '').toLowerCase().trim());
                        if (dateCol === -1) dateCol = lowerCaseRow.findIndex(header => headerKeywords.date.some(kw => header.includes(kw)));
                        if (descCol === -1) descCol = lowerCaseRow.findIndex(header => headerKeywords.desc.some(kw => header.includes(kw)));
                        if (valueCol === -1) valueCol = lowerCaseRow.findIndex(header => headerKeywords.value.some(kw => header.includes(kw)));
                        if (typeCol === -1) typeCol = lowerCaseRow.findIndex(header => headerKeywords.type.some(kw => header.includes(kw)));
                        
                        if (dateCol !== -1 && descCol !== -1 && valueCol !== -1) { 
                            headerRowIndex = i;
                            break;
                        }
                    }
                }
                
                if (dateCol === -1 || descCol === -1 || valueCol === -1) { 
                    showFeedback(`Colunas essenciais (Data, Descrição, Valor) não encontradas no arquivo ${fileExtension}.`, 'error');
                    return parsedTransactions;
                }
                
                const dataStartIndex = headerRowIndex === -1 ? 0 : headerRowIndex + 1;

                for (let i = dataStartIndex; i < json.length; i++) {
                    const row = json[i];
                    if (!Array.isArray(row) || row.every(cell => String(cell || '').trim() === '')) {
                        continue; 
                    }

                    const dateRaw = row[dateCol];
                    const description = String(row[descCol] || '').trim();
                    const valueRaw = String(row[valueCol] || '0').trim();
                    const typeRaw = typeCol !== -1 ? String(row[typeCol] || '').toLowerCase().trim() : '';

                    if (!description && !valueRaw) continue; 

                    let date;
                    if (dateRaw instanceof Date && !isNaN(dateRaw)) {
                        date = dateRaw;
                    } else if (typeof dateRaw === 'string' && dateRaw.trim()) {
                        const partsSlash = dateRaw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/); 
                        const partsDash = dateRaw.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/); 
                        if (partsSlash) {
                            let day = parseInt(partsSlash[1]);
                            let month = parseInt(partsSlash[2]) - 1;
                            let year = parseInt(partsSlash[3]);
                            if (year < 100) year += (year > 50 ? 1900 : 2000); 
                            date = new Date(year, month, day);
                        } else if (partsDash) {
                            date = new Date(partsDash[1], parseInt(partsDash[2]) - 1, partsDash[3]);
                        } else {
                            const parsedAttempt = Date.parse(dateRaw); 
                            if (!isNaN(parsedAttempt)) date = new Date(parsedAttempt);
                            else date = new Date(); 
                        }
                    } else {
                         date = new Date(); 
                    }
                    const formattedDate = date instanceof Date && !isNaN(date) ? date.toISOString().split('T')[0] : new Date().toISOString().split('T')[0];
                    
                    let valueString = valueRaw.replace(/[^\d,.\-]/g, '');
                    const lastComma = valueString.lastIndexOf(',');
                    const lastDot = valueString.lastIndexOf('.');

                    if (lastComma > -1 && lastDot > -1) { 
                        if (lastComma > lastDot) { 
                            valueString = valueString.replace(/\./g, '').replace(',', '.');
                        } else { 
                            valueString = valueString.replace(/,/g, '');
                        }
                    } else if (lastComma > -1) { 
                        valueString = valueString.replace(',', '.');
                    }
                    const value = parseFloat(valueString);
                    
                    let transactionType = 'despesa'; 
                    let fundamentalType = 'despesa';
                    const isCredit = typeRaw.includes('receita') || typeRaw.includes('credit') || typeRaw.includes('crédito') || typeRaw.includes('c') || typeRaw.startsWith('r');
                    const isDebit = typeRaw.includes('despesa') || typeRaw.includes('debit') || typeRaw.includes('débito') || typeRaw.includes('d') || typeRaw.startsWith('d');

                    if (isCredit && !isDebit) {
                        transactionType = 'receita';
                        fundamentalType = 'receita';
                    } else if (isDebit && !isCredit) {
                        transactionType = 'despesa';
                        fundamentalType = 'despesa';
                    } else if (!isNaN(value)) { 
                        transactionType = value >= 0 ? 'receita' : 'despesa';
                        fundamentalType = transactionType;
                    }
                    
                    if (!isNaN(value) && description) {
                        parsedTransactions.push({
                            id: generateUniqueId(), date: formattedDate, description, 
                            value: Math.abs(value), type: transactionType, fundamentalType,
                            category: `Importado ${fileExtension.toUpperCase()}`, 
                            accountId: '', isCreditCard: false, installments: '1/1', isPaid: true 
                        });
                    }
                }
            } catch (e) {
                console.error(`Erro no parseExcelCsv (${fileExtension}):`, e);
                showFeedback(`Erro ao ler o arquivo ${fileExtension}.`, 'error');
                 return []; 
            }
            if (parsedTransactions.length === 0 && data.length > 10) showFeedback(`Nenhuma transação encontrada no ${fileExtension} ou formato não reconhecido.`, 'info');
            else if (parsedTransactions.length > 0) showFeedback(`${parsedTransactions.length} transações do ${fileExtension} carregadas para revisão.`, 'success');
            return parsedTransactions;
        };

        const parseWord = async (file) => {
            if (typeof mammoth === 'undefined') {
                showFeedback('Biblioteca de importação de Word (mammoth.js) não carregada.', 'error');
                finalizeImportProcessing([]); return []; 
            }
            showFeedback("Extraindo texto do arquivo Word...", 'info');
            try {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                const text = result.value;
                if (text.trim()) {
                    return await processTextWithAIForTransactions(text); 
                } else {
                    showFeedback("Nenhum texto encontrado no arquivo Word.", 'info');
                    return [];
                }
            } catch (err) {
                console.error("Erro ao processar arquivo Word:", err);
                showFeedback("Erro ao extrair texto do Word. Formatos .doc antigos podem não ser suportados. Tente .docx.", 'error');
                return [];
            }
        };

        const parseImage = async (file) => {
            if (typeof Tesseract === 'undefined' || typeof Tesseract.createWorker !== 'function') {
                showFeedback('Biblioteca de OCR (Tesseract.js) não carregada ou inválida. Aguarde ou verifique a conexão.', 'error');
                 finalizeImportProcessing([]); return []; 
            }
            showFeedback("Processando imagem com OCR (pode levar alguns segundos)...", 'info');
            try {
                const worker = await Tesseract.createWorker('por', 1, { 
                    logger: m => { 
                        if (m.status === 'recognizing text') {
                            showFeedback(`OCR: ${m.status} ${Math.round(m.progress * 100)}%`, 'info');
                        }
                     } 
                });
                const { data: { text } } = await worker.recognize(file);
                await worker.terminate();
                if (text.trim()) {
                    return await processTextWithAIForTransactions(text); 
                } else {
                    showFeedback("Nenhum texto detectado na imagem via OCR.", 'info');
                    return [];
                }
            } catch (err) {
                console.error("Erro no OCR da imagem:", err);
                showFeedback("Erro ao processar imagem com OCR.", 'error');
                return [];
            }
        };
        
        importHeader.addEventListener('click', () => {
            importSectionContent.classList.toggle('hidden');
            importArrow.classList.toggle('rotated');
        });

        importFileBtn.addEventListener('click', async () => {
            const file = fileInput.files[0];
            if (!file) {
                showFeedback('Por favor, selecione um arquivo.', 'error'); return;
            }

            importedTransactionsToReview = []; 
            importedTransactionsTableBody.innerHTML = ''; 
            importReviewSection.classList.add('hidden'); 

            fileInput.disabled = true;
            importFileBtn.disabled = true;
            
            const reader = new FileReader(); 
            const fileExtension = file.name.split('.').pop().toLowerCase();
            let parsedData = [];

            try {
                if (fileExtension === 'ofx') {
                    reader.onload = (e) => { 
                        try { parsedData = parseOFX(e.target.result); finalizeImportProcessing(parsedData); } 
                        catch (error) { handleImportError(error, "OFX"); }
                    };
                    reader.onerror = (e) => { console.error("FileReader OFX Error:", e); handleImportError(new Error("Erro ao ler arquivo OFX."), "OFX");};
                    reader.readAsText(file);
                } else if (fileExtension === 'csv') {
                    reader.onload = (e) => {
                        try { parsedData = parseExcelCsv(e.target.result, fileExtension, true); finalizeImportProcessing(parsedData); }
                        catch (error) { handleImportError(error, "CSV"); }
                    };
                    reader.onerror = (e) => { console.error("FileReader CSV Error:", e); handleImportError(new Error("Erro ao ler arquivo CSV."), "CSV");};
                    reader.readAsText(file, 'ISO-8859-1'); 
                } else if (['xls', 'xlsx'].includes(fileExtension)) {
                    reader.onload = (e) => {
                        try { parsedData = parseExcelCsv(e.target.result, fileExtension, false); finalizeImportProcessing(parsedData); }
                        catch (error) { handleImportError(error, "Excel"); }
                    };
                    reader.onerror = (e) => { console.error("FileReader Excel Error:", e); handleImportError(new Error("Erro ao ler arquivo Excel."), "Excel");};
                    reader.readAsBinaryString(file);
                } else if (['doc', 'docx'].includes(fileExtension)) {
                    if (fileExtension === 'doc' && (typeof mammoth === 'undefined' || !mammoth.extractRawText)) { 
                         showFeedback('Arquivos .doc podem não ser suportados. Tente .docx ou converta para texto.', 'info');
                         finalizeImportProcessing([]); return;
                    }
                    parsedData = await parseWord(file); 
                    finalizeImportProcessing(parsedData);
                } else if (['png', 'jpg', 'jpeg', 'gif', 'bmp', 'tiff', 'webp'].includes(fileExtension)) {
                    parsedData = await parseImage(file); 
                    finalizeImportProcessing(parsedData);
                } else {
                    showFeedback('Formato de arquivo não suportado: .' + fileExtension, 'error');
                    finalizeImportProcessing([]); 
                }
            } catch (error) { 
                handleImportError(error, `tipo de arquivo ${fileExtension}`);
            }
        });

        renderImportedTransactionsForReview = () => { 
            importedTransactionsTableBody.innerHTML = '';
             if (!importedTransactionsToReview || importedTransactionsToReview.length === 0) {
                importReviewSection.classList.add('hidden');
                return;
            }
            importedTransactionsToReview.forEach((transaction, index) => {
                const tr = document.createElement('tr');
                tr.className = 'bg-white hover:bg-gray-50';
                
                let accountOptionsHTML = accounts.map(acc => 
                    `<option value="${acc.id}" ${transaction.accountId === acc.id ? 'selected' : ''}>${acc.name} (${acc.type === 'overdraft' ? 'C.Especial' : 'Dinheiro'})</option>`
                ).join('');
                let cardOptionsHTML = creditCards.map(card => 
                    `<option value="${card.id}" ${transaction.accountId === card.id ? 'selected' : ''}>${card.name} (Cartão)</option>`
                ).join('');

                const formattedValue = typeof transaction.value === 'number' ? transaction.value.toFixed(2) : '0.00';
                // Inicializa parcelas para importação
                const initialTotalInstallments = transaction.installments ? parseInt(transaction.installments.split('/')[1]) || 1 : 1;
                const initialPaidInstallments = transaction.installments ? parseInt(transaction.installments.split('/')[0]) || 0 : (transaction.isPaid ? 1 : 0) ;


                tr.innerHTML = `
                    <td class="px-2 py-2 whitespace-nowrap text-sm"><input type="date" class="date-input w-full border rounded px-1 py-0.5 text-xs" value="${transaction.date || new Date().toISOString().split('T')[0]}" data-index="${index}"></td>
                    <td class="px-2 py-2 text-sm"><textarea class="description-input w-full border rounded px-1 py-0.5 text-xs" data-index="${index}" rows="2">${transaction.description || ''}</textarea></td>
                    <td class="px-2 py-2 whitespace-nowrap text-sm"><input type="number" step="0.01" class="value-input w-24 border rounded px-1 py-0.5 text-xs" value="${formattedValue}" data-index="${index}"></td>
                    <td class="px-2 py-2 whitespace-nowrap text-sm">
                        <select class="type-input w-full border rounded px-1 py-0.5 text-xs" data-index="${index}">
                            <option value="receita" ${transaction.type === 'receita' ? 'selected' : ''}>Receita</option>
                            <option value="despesa" ${transaction.type === 'despesa' ? 'selected' : ''}>Despesa</option>
                            <option value="saque" ${transaction.type === 'saque' ? 'selected' : ''}>Saque</option>
                            <option value="pix_enviado" ${transaction.type === 'pix_enviado' ? 'selected' : ''}>PIX Enviado</option>
                            <option value="pix_recebido" ${transaction.type === 'pix_recebido' ? 'selected' : ''}>PIX Recebido</option>
                        </select>
                    </td>
                    <td class="px-2 py-2 whitespace-nowrap text-sm">
                        <select class="category-input w-full border rounded px-1 py-0.5 text-xs" data-index="${index}">
                            ${categories.sort((a,b)=> a.localeCompare(b)).map(cat => `<option value="${cat}" ${transaction.category === cat ? 'selected' : ''}>${cat}</option>`).join('')}
                            <option value="nova-categoria-review">Adicionar Nova...</option>
                        </select>
                         <input type="text" class="new-category-input-review hidden w-full border rounded px-1 py-0.5 text-xs mt-1" placeholder="Nova Cat." data-index="${index}" value="${!categories.includes(transaction.category) && transaction.category !== 'Outros' && !transaction.category?.startsWith('Importado') ? transaction.category : ''}">
                    </td>
                    <td class="px-2 py-2 whitespace-nowrap text-sm">
                        <div class="flex space-x-1">
                           <input type="number" min="1" value="${initialTotalInstallments}" class="installments-total-review w-16 border rounded px-1 py-0.5 text-xs" data-index="${index}" title="Total de Parcelas">
                           <input type="number" min="0" value="${initialPaidInstallments}" class="installments-paid-review w-16 border rounded px-1 py-0.5 text-xs" data-index="${index}" title="Parcelas Pagas">
                        </div>
                    </td>
                    <td class="px-2 py-2 whitespace-nowrap text-sm">
                        <select class="account-select-review w-full border rounded px-1 py-0.5 text-xs" data-index="${index}">
                            <option value="">Não Vincular</option>
                            ${accountOptionsHTML}
                            ${cardOptionsHTML}
                        </select>
                    </td>
                    <td class="px-2 py-2 whitespace-nowrap text-sm">
                        <select class="paid-status-input w-full border rounded px-1 py-0.5 text-xs" data-index="${index}">
                            <option value="false" ${!transaction.isPaid ? 'selected' : ''}>Não Pago</option>
                            <option value="true" ${transaction.isPaid ? 'selected' : ''}>Pago</option>
                        </select>
                    </td>`;
                importedTransactionsTableBody.appendChild(tr);

                const accountSelectReviewEl = tr.querySelector('.account-select-review');
                if(transaction.accountId) {
                    accountSelectReviewEl.value = transaction.accountId;
                }
                const categoryInputReview = tr.querySelector('.category-input');
                const newCategoryInputReview = tr.querySelector('.new-category-input-review');
                if (!categories.includes(transaction.category) && transaction.category && transaction.category !== 'Outros' && !transaction.category?.startsWith('Importado')) {
                    categoryInputReview.value = 'nova-categoria-review';
                    newCategoryInputReview.classList.remove('hidden');
                }
                const installmentsTotalReviewEl = tr.querySelector('.installments-total-review');
                const installmentsPaidReviewEl = tr.querySelector('.installments-paid-review');

                // Event listeners para campos editáveis na tabela de revisão
                tr.querySelector('.date-input').addEventListener('change', (e) => importedTransactionsToReview[index].date = e.target.value);
                tr.querySelector('.description-input').addEventListener('input', (e) => importedTransactionsToReview[index].description = e.target.value);
                tr.querySelector('.value-input').addEventListener('change', (e) => {
                     const val = parseFloat(e.target.value) || 0;
                     const originalSignal = importedTransactionsToReview[index].fundamentalTypeOriginalSignal || (val >= 0 ? 1 : -1);
                     importedTransactionsToReview[index].value = Math.abs(val); 
                     
                     if (val !== 0) { 
                        importedTransactionsToReview[index].fundamentalType = val * originalSignal >= 0 ? 'receita' : 'despesa';
                     }
                     
                     if (['receita', 'despesa'].includes(importedTransactionsToReview[index].type)) {
                         importedTransactionsToReview[index].type = importedTransactionsToReview[index].fundamentalType;
                         tr.querySelector('.type-input').value = importedTransactionsToReview[index].type; 
                     }
                });
                tr.querySelector('.type-input').addEventListener('change', (e) => {
                    const newType = e.target.value;
                    importedTransactionsToReview[index].type = newType;
                    if (newType === 'receita' || newType === 'pix_recebido') {
                        importedTransactionsToReview[index].fundamentalType = 'receita';
                    } else {
                        importedTransactionsToReview[index].fundamentalType = 'despesa';
                    }
                });
                
                categoryInputReview.addEventListener('change', (e) => {
                    if(e.target.value === 'nova-categoria-review'){
                        newCategoryInputReview.classList.remove('hidden');
                        newCategoryInputReview.focus();
                        importedTransactionsToReview[index].category = ''; 
                    } else {
                        newCategoryInputReview.classList.add('hidden'); newCategoryInputReview.value = '';
                        importedTransactionsToReview[index].category = e.target.value;
                    }
                });
                newCategoryInputReview.addEventListener('blur', (e) => { 
                     if(e.target.value.trim() && categoryInputReview.value === 'nova-categoria-review'){
                        importedTransactionsToReview[index].category = e.target.value.trim();
                     }
                });

                accountSelectReviewEl.addEventListener('change', (e) => {
                    importedTransactionsToReview[index].accountId = e.target.value;
                    importedTransactionsToReview[index].isCreditCard = e.target.value ? creditCards.some(card => card.id === e.target.value) : false;
                });
                 tr.querySelector('.paid-status-input').addEventListener('change', (e) => importedTransactionsToReview[index].isPaid = e.target.value === 'true');
                 
                 installmentsTotalReviewEl.addEventListener('change', (e) => {
                    let total = parseInt(e.target.value) || 1;
                    if (total < 1) total = 1;
                    e.target.value = total;
                    importedTransactionsToReview[index].installmentsTotal = total;
                    // Garante que parcelas pagas não exceda o total
                    const paidEl = tr.querySelector('.installments-paid-review');
                    if (parseInt(paidEl.value) > total) {
                        paidEl.value = total;
                        importedTransactionsToReview[index].installmentsPaid = total;
                    }
                });
                installmentsPaidReviewEl.addEventListener('change', (e) => {
                    const total = parseInt(tr.querySelector('.installments-total-review').value) || 1;
                    let paid = parseInt(e.target.value) || 0;
                    if (paid < 0) paid = 0;
                    if (paid > total) paid = total;
                    e.target.value = paid;
                    importedTransactionsToReview[index].installmentsPaid = paid;
                });

            });
        };
        
        confirmImportBtn.addEventListener('click', () => {
            let importedCount = 0; let skippedCount = 0; let importErrors = [];
            const transactionsToCommit = [];
            const tempAccounts = JSON.parse(JSON.stringify(accounts));
            const tempCreditCards = JSON.parse(JSON.stringify(creditCards));
            let newCategoriesAddedInReview = [];

            importedTransactionsToReview.forEach((reviewedTx, index) => {
                const categoryInputEl = document.querySelector(`.category-input[data-index="${index}"]`);
                const newCategoryInputEl = document.querySelector(`.new-category-input-review[data-index="${index}"]`);
                const installmentsTotalEl = document.querySelector(`.installments-total-review[data-index="${index}"]`);
                const installmentsPaidEl = document.querySelector(`.installments-paid-review[data-index="${index}"]`);

                reviewedTx.installmentsTotal = parseInt(installmentsTotalEl.value) || 1;
                reviewedTx.installmentsPaid = parseInt(installmentsPaidEl.value) || 0;


                if (categoryInputEl && categoryInputEl.value === 'nova-categoria-review' && newCategoryInputEl && newCategoryInputEl.value.trim()) {
                    const newCatName = newCategoryInputEl.value.trim();
                    if (newCatName && !categories.includes(newCatName) && !newCategoriesAddedInReview.includes(newCatName)) {
                        newCategoriesAddedInReview.push(newCatName);
                    }
                    reviewedTx.category = newCatName || 'Outros'; 
                } else if (categoryInputEl) {
                    reviewedTx.category = categoryInputEl.value || 'Outros';
                }

                 if (!reviewedTx.fundamentalType) {
                    if (reviewedTx.type === 'receita' || reviewedTx.type === 'pix_recebido') {
                        reviewedTx.fundamentalType = 'receita';
                    } else {
                        reviewedTx.fundamentalType = 'despesa';
                    }
                }

                if (!reviewedTx.description || isNaN(reviewedTx.value) || reviewedTx.value <= 0) { 
                    skippedCount++; return;
                }

                // Lógica de parcelamento para transações importadas
                if (reviewedTx.installmentsTotal > 1 && (reviewedTx.fundamentalType === 'despesa')) {
                    const originalValue = reviewedTx.value;
                    const installmentValue = parseFloat((originalValue / reviewedTx.installmentsTotal).toFixed(2));
                    let sumOfInstallments = 0;

                    for (let i = 0; i < reviewedTx.installmentsTotal; i++) {
                        let currentInstallmentValue = installmentValue;
                        if (i === reviewedTx.installmentsTotal - 1) {
                            currentInstallmentValue = parseFloat((originalValue - sumOfInstallments).toFixed(2));
                        }
                        sumOfInstallments += currentInstallmentValue;

                        const transactionDate = new Date(reviewedTx.date);
                        transactionDate.setMonth(transactionDate.getMonth() + i);

                        const installmentTransaction = {
                            ...reviewedTx, // Copia a maioria dos dados
                            id: generateUniqueId(),
                            date: transactionDate.toISOString().split('T')[0],
                            description: `${reviewedTx.description} (${i + 1}/${reviewedTx.installmentsTotal})`,
                            value: currentInstallmentValue,
                            installments: `${i + 1}/${reviewedTx.installmentsTotal}`,
                            isPaid: (i + 1) <= reviewedTx.installmentsPaid,
                            originalGroupId: reviewedTx.id // Usa o ID da transação importada como group ID
                        };
                        
                        // Validação e aplicação de saldo/limite para esta parcela
                        let installmentValid = true;
                        if (installmentTransaction.accountId) {
                            const account = tempAccounts.find(acc => acc.id === installmentTransaction.accountId);
                            const creditCard = tempCreditCards.find(card => card.id === installmentTransaction.accountId);

                            if (installmentTransaction.isCreditCard && creditCard) {
                                if (installmentTransaction.fundamentalType === 'despesa') creditCard.availableLimit -= installmentTransaction.value;
                                else creditCard.availableLimit += installmentTransaction.value;
                            } else if (account) {
                                if (installmentTransaction.isPaid) {
                                    if (installmentTransaction.fundamentalType === 'despesa') {
                                        if (account.type === 'overdraft' && (account.balance - installmentTransaction.value < -account.limit)) {
                                            importErrors.push(`Parcela de ${formatCurrency(installmentTransaction.value)} para ${account.name} excede limite.`);
                                            installmentValid = false;
                                        } else if (installmentValid) {
                                            account.balance -= installmentTransaction.value;
                                        }
                                    } else if (installmentValid) {
                                        account.balance += installmentTransaction.value;
                                    }
                                }
                            } else {
                                importErrors.push(`Conta/Cartão ID ${installmentTransaction.accountId} não encontrado para parcela.`);
                                installmentValid = false;
                            }
                        }
                        if (installmentValid) {
                            transactionsToCommit.push(installmentTransaction);
                        } else {
                            skippedCount++; // Se uma parcela falhar, as outras do grupo também podem ser afetadas
                        }
                    }
                    importedCount++; // Conta a transação original como importada, mesmo que dividida
                } else { // Transação única
                    let transactionValid = true;
                    if (reviewedTx.accountId){ 
                        const account = tempAccounts.find(acc => acc.id === reviewedTx.accountId);
                        const creditCard = tempCreditCards.find(card => card.id === reviewedTx.accountId);

                        if (reviewedTx.isCreditCard && creditCard) {
                            if (reviewedTx.fundamentalType === 'despesa') creditCard.availableLimit -= reviewedTx.value;
                            else creditCard.availableLimit += reviewedTx.value;
                        } else if (account) { 
                            if (reviewedTx.isPaid) {
                                if (reviewedTx.fundamentalType === 'despesa') {
                                    if (account.type === 'overdraft' && (account.balance - reviewedTx.value < -account.limit)) {
                                        importErrors.push(`Importada de ${formatCurrency(reviewedTx.value)} para ${account.name} excede limite.`);
                                        transactionValid = false;
                                    } else if(transactionValid) { 
                                        account.balance -= reviewedTx.value;
                                    }
                                } else if(transactionValid) { 
                                    account.balance += reviewedTx.value;
                                }
                            }
                        } else { 
                            importErrors.push(`Conta/Cartão ID ${reviewedTx.accountId} não encontrado.`);
                            transactionValid = false;
                        }
                    }
                    if (transactionValid) {
                        transactionsToCommit.push({ ...reviewedTx, id: generateUniqueId(), installments: '1/1' }); 
                        importedCount++;
                    } else {
                        skippedCount++; 
                    }
                }
            });
            
            if (newCategoriesAddedInReview.length > 0) {
                categories.push(...newCategoriesAddedInReview);
                saveCategories();
                populateCategorySelect(); 
                populateCategorySelect(editCategorySelect);
                if (!importReviewSection.classList.contains('hidden')) {
                     renderImportedTransactionsForReview(); 
                }
            }

            if (importErrors.length > 0) {
                showFeedback(`Erro(s) na importação: ${importErrors.join(' ')} ${skippedCount > 0 ? (importedCount > 0 ? 'Outras ' : '') + skippedCount + ' transações ignoradas.' : ''}`, 'error');
                if (importedCount === 0) return; 
            }

            transactions.push(...transactionsToCommit);
            accounts = tempAccounts; 
            creditCards = tempCreditCards; 

            saveTransactions(); saveAccounts(); saveCreditCards();
            renderTransactions(); updateSummary(); renderMonthlySummary(); 
            renderDetailedCardBills(); checkCreditCardDueDates();
            
            importedTransactionsToReview = []; 
            importedTransactionsTableBody.innerHTML = ''; 
            importReviewSection.classList.add('hidden'); 
            
            let feedbackMsg = `Importação concluída. ${importedCount} transação(ões) originais processada(s) (podem ter gerado múltiplas parcelas).`;
            if (skippedCount > 0 && importErrors.length === 0) feedbackMsg += ` ${skippedCount} ignorada(s) por falta de vínculo ou dados.`;
            else if (skippedCount > 0 && importErrors.length > 0 && importedCount > 0) feedbackMsg += ` ${skippedCount} adicional(is) ignorada(s).`;

            showFeedback(feedbackMsg, importedCount > 0 ? 'success' : (importErrors.length > 0 ? 'error' : 'info') );
        });

        cancelReviewBtn.addEventListener('click', () => {
            importedTransactionsToReview = []; importedTransactionsTableBody.innerHTML = '';
            importReviewSection.classList.add('hidden'); fileInput.value = '';
            showFeedback('Importação cancelada.', 'info');
             fileInput.disabled = false; 
            importFileBtn.disabled = false; 
        });
        
        // --- Funções de Download ---
        downloadXlsxBtn.addEventListener('click', () => {
            const beginningOfCurrentMonth = new Date(currentYear, currentMonth, 1);
            beginningOfCurrentMonth.setHours(0,0,0,0);
            const dataToExport = transactions.filter(t => {
                const tDate = new Date(t.date); tDate.setHours(0,0,0,0);
                const isInCurrentMonthAndYear = tDate.getMonth() === currentMonth && tDate.getFullYear() === currentYear;
                const isPendingFromPreviousMonth = tDate < beginningOfCurrentMonth && !t.isPaid;
                return isInCurrentMonthAndYear || isPendingFromPreviousMonth;
            }).sort((a, b) => new Date(a.date) - new Date(b.date))
            .map(t => {
                let typeDisplay = t.type;
                if (t.type === 'pix_enviado') typeDisplay = 'PIX Enviado';
                else if (t.type === 'pix_recebido') typeDisplay = 'PIX Recebido';
                else if (t.type === 'saque') typeDisplay = 'Saque';
                else if (t.type === 'receita') typeDisplay = 'Receita';
                else if (t.type === 'despesa') typeDisplay = 'Despesa';

                return {
                    Data: new Date(t.date).toLocaleDateString('pt-BR'), Descrição: t.description, Valor: t.value,
                    Tipo: typeDisplay, Categoria: t.category,
                    'Conta / Cartão': t.accountId ? (t.isCreditCard ? (creditCards.find(c => c.id === t.accountId)?.name || 'N/A') : (accounts.find(a => a.id === t.accountId)?.name || 'N/A')) : "Não Vinculada",
                    Parcela: t.installments, Pago: t.isPaid ? 'Sim' : 'Não'
                }
            });

            if (dataToExport.length === 0) {
                showFeedback('Não há transações para baixar.', 'info'); return;
            }
            const worksheet = XLSX.utils.json_to_sheet(dataToExport);
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Transacoes");
            const monthName = new Date(currentYear, currentMonth).toLocaleDateString('pt-BR', { month: 'long' });
            XLSX.writeFile(workbook, `transacoes_${monthName}_${currentYear}.xlsx`);
            showFeedback('Planilha baixada!', 'success');
        });

        // --- Faturas Detalhadas de Cartão ---
        detailedCardBillsHeader.addEventListener('click', () => {
            detailedCardBillsContent.classList.toggle('hidden');
            detailedCardBillsArrow.classList.toggle('rotated');
        });
        const renderDetailedCardBills = () => {
            detailedCardBillsList.innerHTML = '';
            if (creditCards.length === 0) {
                noCardBillsMessage.classList.remove('hidden'); return;
            } else {
                noCardBillsMessage.classList.add('hidden');
            }
            creditCards.forEach(card => {
                const currentMonthBill = transactions.reduce((sum, t) => {
                    const tDate = new Date(t.date);
                    if (t.accountId === card.id && t.isCreditCard && t.fundamentalType === 'despesa' && !t.isPaid &&
                        tDate.getMonth() === currentMonth && tDate.getFullYear() === currentYear) {
                        return sum + t.value;
                    }
                    return sum;
                }, 0);
                const li = document.createElement('li');
                li.className = 'p-4 flex justify-between items-center bg-white hover:bg-gray-50';
                li.innerHTML = `<div class="font-semibold text-gray-800">${card.name}: <span class="text-purple-700">${formatCurrency(currentMonthBill)}</span></div>
                                <div class="text-sm text-gray-600">Vencimento: Dia ${card.dueDay}</div>`;
                detailedCardBillsList.appendChild(li);
            });
        };

        // --- Função para verificar datas de vencimento de cartão ---
        const checkCreditCardDueDates = () => {
            const today = new Date(); today.setHours(0, 0, 0, 0); 
            creditCards.forEach(card => {
                const dueDay = card.dueDay;
                let billDueDate = new Date(today.getFullYear(), today.getMonth(), dueDay);
                billDueDate.setHours(0, 0, 0, 0);
                if (today.getDate() > dueDay) billDueDate.setMonth(today.getMonth() + 1);
                
                let billClosingDate = new Date(billDueDate.getTime());
                billClosingDate.setDate(billDueDate.getDate() - 10); 
                billClosingDate.setHours(0, 0, 0, 0);

                if (today.getTime() === billClosingDate.getTime()) {
                    const closingBillAmount = transactions.reduce((sum, t) => { 
                         const tDate = new Date(t.date);
                         let cycleStartApprox = new Date(billClosingDate); 
                         cycleStartApprox.setDate(cycleStartApprox.getDate() - (card.dueDay > 10 ? 30 : 28)); 
                         
                         if (t.accountId === card.id && t.isCreditCard && t.fundamentalType === 'despesa' && tDate >= cycleStartApprox && tDate < billClosingDate ) {
                            return sum + t.value;
                         }
                         return sum;
                    },0);
                    if (closingBillAmount > 0) {
                         showFeedback(`FATURA FECHADA: ${card.name} fechou hoje! Valor (aprox.): ${formatCurrency(closingBillAmount)}. Venc.: ${billDueDate.toLocaleDateString('pt-BR')}`, 'info');
                    }
                }

                const diffTimeDue = billDueDate.getTime() - today.getTime();
                const diffDaysDue = Math.ceil(diffTimeDue / (1000 * 60 * 60 * 24));
                
                const currentMonthBillForNotification = transactions.reduce((sum, t) => { 
                    const tDate = new Date(t.date);
                    if (t.accountId === card.id && t.isCreditCard && t.fundamentalType === 'despesa' && !t.isPaid && 
                        tDate >= billClosingDate && tDate < billDueDate ) { 
                        return sum + t.value;
                    }
                    return sum;
                },0);

                if (diffDaysDue <= 7 && diffDaysDue >= 0 && currentMonthBillForNotification > 0) {
                    const msgBase = `VENCIMENTO PRÓXIMO: ${card.name} vence ${diffDaysDue === 0 ? 'HOJE' : 'em ' + diffDaysDue + ' dia(s)'}!`;
                    showFeedback(`${msgBase} Valor (aprox.): ${formatCurrency(currentMonthBillForNotification)}`, 'info');
                }
            });
        };

        // --- Integração com IA do Google (Gemini) ---
        const getAICategorySuggestion = async (description) => {
            if (!description || description.trim() === "") {
                showFeedback("Por favor, insira uma descrição para obter uma sugestão de categoria.", "info");
                return;
            }

            aiSuggestCategoryBtn.disabled = true;
            aiSuggestCategorySpinner.classList.remove('hidden');
            aiSuggestCategoryBtn.querySelector('.bi-stars').classList.add('hidden'); 
            showFeedback("Consultando IA para sugestão de categoria...", "info");

            const existingCategoriesString = categories.join(", ");
            const prompt = `Com base na descrição de transação financeira "${description}", sugira a categoria mais apropriada em português do Brasil. As categorias existentes são: ${existingCategoriesString}. Se nenhuma existente se encaixar perfeitamente, sugira uma nova categoria concisa ou a mais próxima. Retorne apenas o nome da categoria sugerida. Se a descrição for muito vaga, retorne "Outros".`;
            
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory,
                 safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ]
            };
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API Gemini:", errorData);
                    throw new Error(`Erro da API: ${response.status} - ${errorData.error?.message || 'Erro desconhecido'}`);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    
                    let suggestedCategory = result.candidates[0].content.parts[0].text.trim();
                    suggestedCategory = suggestedCategory.replace(/^["']|["']$/g, '').replace(/\.$/, '').trim();

                    showFeedback(`Sugestão da IA: ${suggestedCategory}`, "success");
                    const existingCategoryMatch = categories.find(cat => cat.toLowerCase() === suggestedCategory.toLowerCase());

                    if (existingCategoryMatch) {
                        categorySelect.value = existingCategoryMatch;
                        newCategoryInput.classList.add('hidden');
                        newCategoryInput.value = '';
                    } else if (suggestedCategory && suggestedCategory.toLowerCase() !== "outros" && suggestedCategory.length < 30) { 
                        categorySelect.value = 'nova-categoria';
                        newCategoryInput.classList.remove('hidden');
                        newCategoryInput.value = suggestedCategory; 
                        showFeedback(`Sugestão da IA: "${suggestedCategory}". Adicione como nova ou escolha uma existente.`, "info");
                    } else { 
                         const outrosOption = Array.from(categorySelect.options).find(opt => opt.value.toLowerCase() === 'outros');
                         if (outrosOption) categorySelect.value = outrosOption.value;
                         else if (categorySelect.options.length > 1 && categorySelect.options[1].value !== "") categorySelect.selectedIndex = 1; 
                         newCategoryInput.classList.add('hidden');
                         newCategoryInput.value = '';
                    }
                    categorySelect.dispatchEvent(new Event('change'));
                } else {
                    console.warn("Resposta da API Gemini não continha sugestão válida:", result);
                    showFeedback("IA não conseguiu sugerir uma categoria desta vez.", "info");
                }
            } catch (error) {
                console.error("Erro ao chamar API Gemini:", error);
                showFeedback(`Erro ao obter sugestão da IA: ${error.message}`, "error");
            } finally {
                aiSuggestCategoryBtn.disabled = false;
                aiSuggestCategorySpinner.classList.add('hidden');
                aiSuggestCategoryBtn.querySelector('.bi-stars').classList.remove('hidden'); 
            }
        };

        aiSuggestCategoryBtn.addEventListener('click', () => {
            const description = document.getElementById('description').value.trim();
            getAICategorySuggestion(description);
        });

        const getAIExpenseAnalysis = async () => {
            aiAnalyzeExpensesBtn.disabled = true;
            aiAnalyzeExpensesSpinner.classList.remove('hidden');
            aiAnalyzeExpensesBtn.querySelector('.bi-clipboard2-data').classList.add('hidden');
            showFeedback("Analisando seus gastos com IA...", "info");
            aiAnalysisModalBody.innerHTML = '<p class="text-center">Analisando seus gastos... Isso pode levar alguns instantes.</p>';
            aiAnalysisModal.classList.remove('hidden');

            const transactionsToAnalyze = transactions.filter(t => {
                const transactionDate = new Date(t.date);
                return transactionDate.getMonth() === currentMonth && transactionDate.getFullYear() === currentYear;
            });

            if (transactionsToAnalyze.length === 0) {
                aiAnalysisModalBody.innerHTML = '<p>Não há transações neste mês para analisar.</p>';
                aiAnalyzeExpensesBtn.disabled = false;
                aiAnalyzeExpensesSpinner.classList.add('hidden');
                aiAnalyzeExpensesBtn.querySelector('.bi-clipboard2-data').classList.remove('hidden');
                return;
            }

            const simplifiedTransactions = transactionsToAnalyze.map(t => ({
                descricao: t.description,
                valor: t.value,
                tipo: t.fundamentalType, 
                categoria: t.category,
                data: t.date.substring(5) 
            }));

            const monthName = new Date(currentYear, currentMonth).toLocaleDateString('pt-BR', { month: 'long' });
            const prompt = `
                Analise as seguintes transações financeiras do mês de ${monthName} de ${currentYear}.
                Dados das transações (descrição, valor, tipo (receita/despesa), categoria, data parcial MM-DD):
                ${JSON.stringify(simplifiedTransactions)}

                Forneça um resumo conciso em português do Brasil, com as seguintes seções:
                1.  **Visão Geral do Mês:** Total de receitas, total de despesas e o saldo do mês (receitas - despesas).
                2.  **Principais Categorias de Despesa:** Liste as 3 principais categorias onde mais se gastou e seus totais. Se houver menos de 3, liste as que existirem.
                3.  **Observações e Dicas (opcional):** Com base nos dados, forneça 1 ou 2 observações breves e acionáveis ou dicas gerais de economia. Foque em padrões de gastos. Se não houver insights claros, omita esta seção ou diga que os gastos foram diversificados.
                Formate a resposta de forma clara, usando markdown simples para títulos (ex: ## Título), listas com marcadores (*) e negrito (**palavra**). Não use HTML.
            `;
            
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory,
                 safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ]
            };
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API Gemini (Análise):", errorData);
                    throw new Error(`Erro da API: ${response.status} - ${errorData.error?.message || 'Erro desconhecido'}`);
                }
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    
                    let analysisText = result.candidates[0].content.parts[0].text;
                    analysisText = analysisText
                        .replace(/^## (.*$)/gm, '<h4 class="text-xl font-semibold text-gray-800 mt-4 mb-2">$1</h4>')
                        .replace(/^### (.*$)/gm, '<h5 class="text-lg font-semibold text-gray-700 mt-3 mb-1">$1</h5>')
                        .replace(/^\* (.*$)/gm, '<li class="ml-5 list-disc text-gray-700">$1</li>')
                        .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>')
                        .replace(/\n/g, '<br>');
                    
                    analysisText = analysisText.replace(/<br>\s*<ul>/g, '<ul>').replace(/<\/ul>\s*<br>/g, '</ul>'); 

                    aiAnalysisModalBody.innerHTML = analysisText;
                    showFeedback("Análise de gastos concluída!", "success");
                } else {
                    console.warn("Resposta da API Gemini (Análise) não continha dados válidos:", result);
                    aiAnalysisModalBody.innerHTML = '<p>A IA não conseguiu gerar uma análise desta vez. Tente novamente mais tarde.</p>';
                    showFeedback("Não foi possível gerar a análise.", "info");
                }

            } catch (error) {
                console.error("Erro ao chamar API Gemini (Análise):", error);
                aiAnalysisModalBody.innerHTML = `<p class="text-red-600">Erro ao obter análise da IA: ${error.message}</p>`;
                showFeedback(`Erro na análise com IA: ${error.message}`, "error");
            } finally {
                aiAnalyzeExpensesBtn.disabled = false;
                aiAnalyzeExpensesSpinner.classList.add('hidden');
                aiAnalyzeExpensesBtn.querySelector('.bi-clipboard2-data').classList.remove('hidden');
            }
        };

        aiAnalyzeExpensesBtn.addEventListener('click', getAIExpenseAnalysis);
        closeAiAnalysisModalBtn.addEventListener('click', () => aiAnalysisModal.classList.add('hidden'));
        okAiAnalysisModalBtn.addEventListener('click', () => aiAnalysisModal.classList.add('hidden'));

        // --- Metas Financeiras com IA ---
        financialGoalsHeader.addEventListener('click', () => {
            financialGoalsContent.classList.toggle('hidden');
            financialGoalsArrow.classList.toggle('rotated');
        });

        addFinancialGoalForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('goal-name').value.trim();
            const targetAmount = parseFloat(document.getElementById('goal-target-amount').value);
            const deadline = document.getElementById('goal-deadline').value;

            if (!name || isNaN(targetAmount) || targetAmount <= 0 || !deadline) {
                showFeedback("Por favor, preencha todos os campos da meta corretamente.", "error");
                return;
            }
            if (new Date(deadline) <= new Date()) {
                showFeedback("O prazo da meta deve ser uma data futura.", "error");
                return;
            }

            const newGoal = {
                id: generateUniqueId(),
                name,
                targetAmount,
                deadline,
                currentAmountSaved: 0, 
                aiPlan: "",
                status: 'active' 
            };

            addGoalAiPlanBtn.disabled = true;
            addGoalAiPlanSpinner.classList.remove('hidden');
            const aiPlanText = await getAIGoalPlan(newGoal);
            addGoalAiPlanBtn.disabled = false;
            addGoalAiPlanSpinner.classList.add('hidden');
            
            if (aiPlanText) { 
                newGoal.aiPlan = aiPlanText;
                financialGoals.push(newGoal);
                saveFinancialGoals();
                renderFinancialGoals();
                addFinancialGoalForm.reset();
                showFeedback(`Meta "${name}" adicionada e plano gerado pela IA!`, "success");
                aiGoalPlanModalTitle.textContent = `Plano para: ${newGoal.name}`;
                aiGoalPlanModalBody.innerHTML = newGoal.aiPlan.replace(/\n/g, '<br>').replace(/## (.*$)/gm, '<h4 class="text-lg font-semibold text-gray-700 mt-3 mb-1">$1</h4>').replace(/^\* (.*$)/gm, '<li class="ml-5 list-disc text-gray-700">$1</li>');
                aiGoalPlanModal.classList.remove('hidden');
            } else {
                showFeedback(`Não foi possível gerar o plano da IA para a meta "${name}". Tente novamente.`, "error");
            }
        });

        const getAIGoalPlan = async (goal) => {
            showFeedback(`Gerando plano com IA para "${goal.name}"...`, "info");

            let totalExpensesLastMonth = 0;
            let totalIncomeLastMonth = 0;
            const oneMonthAgo = new Date();
            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);

            transactions.forEach(t => {
                const transactionDate = new Date(t.date);
                if (transactionDate >= oneMonthAgo) {
                    if (t.fundamentalType === 'despesa') totalExpensesLastMonth += t.value;
                    else if (t.fundamentalType === 'receita') totalIncomeLastMonth += t.value;
                }
            });
            
            const categoriesLastMonth = transactions.reduce((acc, t) => {
                const transactionDate = new Date(t.date);
                 if (transactionDate >= oneMonthAgo && t.fundamentalType === 'despesa') {
                    acc[t.category] = (acc[t.category] || 0) + t.value;
                }
                return acc;
            }, {});
            const categoriesString = Object.entries(categoriesLastMonth)
                                     .map(([cat, val]) => `${cat}: ${formatCurrency(val)}`)
                                     .join(', ') || "Nenhuma despesa registrada no último mês.";


            const prompt = `
                Eu quero atingir a meta financeira: "${goal.name}" de ${formatCurrency(goal.targetAmount)} até ${new Date(goal.deadline).toLocaleDateString('pt-BR')}.
                Minha renda mensal aproximada no último mês foi de ${formatCurrency(totalIncomeLastMonth)} e meus gastos totais foram de ${formatCurrency(totalExpensesLastMonth)}.
                Minhas principais categorias de despesa no último mês foram: ${categoriesString}.
                
                Crie um plano de economia realista em português do Brasil para me ajudar a atingir esta meta.
                O plano deve incluir:
                1.  **Economia Mensal Necessária:** Calcule quanto preciso economizar por mês.
                2.  **Dicas Práticas (2-3):** Sugira ajustes específicos nos meus gastos (baseado nas categorias fornecidas, se possível) ou hábitos de economia para alcançar a economia mensal.
                3.  **Observação Motivacional:** Uma frase curta de encorajamento.

                Formate a resposta usando markdown simples (## para títulos, * para listas). Não use HTML.
                Se a meta parecer irrealista dado o prazo e a renda/gastos, mencione isso de forma construtiva e sugira ajustar o prazo ou o valor da meta, ou aumentar a economia mensal drasticamente.
            `;

            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory,
                 safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
                ]
            };
            const apiKey = "AIzaSyDdSa50-zxd3Cu3uX-AqLlfprnRtdhmT_0"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`Erro da API Gemini: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content.parts[0].text) {
                    return result.candidates[0].content.parts[0].text;
                }
                return "Não foi possível gerar um plano da IA.";
            } catch (error) {
                console.error("Erro ao gerar plano da meta com IA:", error);
                showFeedback("Erro ao contatar IA para plano da meta.", "error");
                return null; 
            }
        };

        const renderFinancialGoals = () => {
            financialGoalsList.innerHTML = '';
            const activeGoals = financialGoals.filter(g => g.status === 'active');

            if (activeGoals.length === 0) {
                noFinancialGoalsMessage.classList.remove('hidden');
                return;
            }
            noFinancialGoalsMessage.classList.add('hidden');

            activeGoals.forEach(goal => {
                const li = document.createElement('li');
                const deadlineDate = new Date(goal.deadline);
                const today = new Date();
                const timeDiff = deadlineDate.getTime() - today.getTime();
                const daysRemaining = Math.max(0, Math.ceil(timeDiff / (1000 * 60 * 60 * 24)));
                const monthsRemaining = Math.max(0, Math.ceil(daysRemaining / 30.44)); 


                li.innerHTML = `
                    <div class="goal-details">
                        <h4 class="text-lg font-semibold text-green-700">${goal.name}</h4>
                        <p><strong>Meta:</strong> ${formatCurrency(goal.targetAmount)}</p>
                        <p><strong>Prazo:</strong> ${deadlineDate.toLocaleDateString('pt-BR')} (${daysRemaining} dias / ${monthsRemaining} meses restantes)</p>
                        <p><strong>Status:</strong> ${goal.status === 'active' ? 'Ativa' : 'Concluída'}</p>
                    </div>
                    <div class="ai-plan-content mt-2 ${goal.aiPlan ? '' : 'hidden'}">
                        <h5 class="text-md font-semibold text-gray-600 mb-1">Plano da IA:</h5>
                        <div class="text-sm text-gray-700">${goal.aiPlan ? goal.aiPlan.replace(/\n/g, '<br>').replace(/## (.*$)/gm, '<strong class="block mt-2 mb-1 text-md">$1</strong>').replace(/^\* (.*$)/gm, '<li class="ml-4 list-disc">$1</li>') : 'Nenhum plano gerado ainda.'}</div>
                    </div>
                    <div class="goal-actions mt-3">
                        <button data-goal-id="${goal.id}" class="toggle-ai-plan-btn px-3 py-1.5 text-sm bg-blue-500 text-white rounded-md hover:bg-blue-600">
                            ${goal.aiPlan ? 'Ver/Ocultar Plano da IA' : 'Obter Plano da IA ✨'}
                        </button>
                        <button data-goal-id="${goal.id}" class="complete-goal-btn px-3 py-1.5 text-sm bg-green-500 text-white rounded-md hover:bg-green-600">Marcar Concluída</button>
                        <button data-goal-id="${goal.id}" class="delete-goal-btn px-3 py-1.5 text-sm bg-red-500 text-white rounded-md hover:bg-red-600">Excluir</button>
                    </div>
                `;
                financialGoalsList.appendChild(li);

                li.querySelector('.toggle-ai-plan-btn').addEventListener('click', async (e) => {
                    const goalId = e.currentTarget.dataset.goalId;
                    const goalIndex = financialGoals.findIndex(g => g.id === goalId);
                    if (goalIndex > -1) {
                        const planContentDiv = e.currentTarget.closest('li').querySelector('.ai-plan-content');
                        if (financialGoals[goalIndex].aiPlan && !planContentDiv.classList.contains('hidden') && e.currentTarget.textContent.includes('Ocultar')) {
                            planContentDiv.classList.add('hidden');
                            e.currentTarget.textContent = 'Ver Plano da IA';
                        } else {
                            if (!financialGoals[goalIndex].aiPlan) {
                                e.currentTarget.disabled = true;
                                e.currentTarget.innerHTML = 'Gerando... <span class="ai-btn-spinner"></span>';
                                const plan = await getAIGoalPlan(financialGoals[goalIndex]);
                                if (plan) {
                                    financialGoals[goalIndex].aiPlan = plan;
                                    saveFinancialGoals();
                                    planContentDiv.querySelector('div').innerHTML = plan.replace(/\n/g, '<br>').replace(/## (.*$)/gm, '<strong class="block mt-2 mb-1 text-md">$1</strong>').replace(/^\* (.*$)/gm, '<li class="ml-4 list-disc">$1</li>');
                                }
                                e.currentTarget.disabled = false;
                            }
                            planContentDiv.classList.remove('hidden');
                            e.currentTarget.innerHTML = 'Ocultar Plano da IA';
                            if(!financialGoals[goalIndex].aiPlan) e.currentTarget.textContent = 'Obter Plano da IA ✨'; 
                        }
                    }
                });

                li.querySelector('.complete-goal-btn').addEventListener('click', (e) => {
                    const goalId = e.currentTarget.dataset.goalId;
                    const goalIndex = financialGoals.findIndex(g => g.id === goalId);
                    if (goalIndex > -1) {
                        financialGoals[goalIndex].status = 'completed';
                        saveFinancialGoals();
                        renderFinancialGoals(); 
                        showFeedback(`Meta "${financialGoals[goalIndex].name}" marcada como concluída!`, 'success');
                    }
                });
                li.querySelector('.delete-goal-btn').addEventListener('click', (e) => {
                    const goalId = e.currentTarget.dataset.goalId;
                    financialGoals = financialGoals.filter(g => g.id !== goalId);
                    saveFinancialGoals();
                    renderFinancialGoals();
                    showFeedback("Meta excluída.", "info");
                });
            });
        };

        financialGoalsHeader.addEventListener('click', () => {
            financialGoalsContent.classList.toggle('hidden');
            financialGoalsArrow.classList.toggle('rotated');
        });
        closeAiGoalPlanModalBtn.addEventListener('click', () => aiGoalPlanModal.classList.add('hidden'));
        okAiGoalPlanModalBtn.addEventListener('click', () => aiGoalPlanModal.classList.add('hidden'));


        // Carregamento inicial
        window.onload = () => {
            loadData();
            updateMonthlyDisplay(); 
        };
    </script>
</body>
</html>
```


